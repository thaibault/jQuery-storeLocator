// Generated by CoffeeScript 1.9.0

/*
[Project page](http://torben.website/jQuery-storeLocator)

This plugin provides a google application interface based store locator.

Copyright Torben Sickert 16.12.2012

License
-------

This library written by Torben Sickert stand under a creative commons naming
3.0 unported license. see http://creativecommons.org/licenses/by/3.0/deed.de

Extending this module
---------------------

For conventions see require on https://github.com/thaibault/require

Author
------

t.sickert["~at~"]gmail.com (Torben Sickert)

Version
-------

1.0 stable
 */

(function() {
  var main,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  main = function($) {
    var StoreLocator;
    StoreLocator = (function(_super) {
      __extends(StoreLocator, _super);

      function StoreLocator() {
        return StoreLocator.__super__.constructor.apply(this, arguments);
      }


      /*
          A jQuery storelocator plugin.
      
          Expected store data format:
      
          {latitude: NUMBER, longitude: NUMBER, markerIconFileName: STRING}
       */

      StoreLocator.prototype.__name__ = 'StoreLocator';

      StoreLocator.prototype.initialize = function(options) {
        var loaded;
        if (options == null) {
          options = {};
        }

        /*Entry point for object orientated jQuery plugin. */
        this.currentSearchResults = [];
        this.currentSearchText = null;
        this.resultsDomNode = null;
        this.currentSearchResultsDomNode = null;
        this.currentlyOpenWindow = null;
        this.currentlyHighlightedMarker = null;
        this.searchResultsDirty = false;
        this.seenLocations = [];
        this.markers = [];
        this.currentSearchResultRange = null;
        this._options = {

          /*
              URL to retrieve stores, list of stores or object describing
              bounds to create random stores within. If a
              "generateProperties" function is given it will be called to
              retrieve additional properties for each store. The
              specified store will be given to the function.
           */
          stores: {
            northEast: {
              latitude: 85,
              longitude: 180
            },
            southWest: {
              latitude: -85,
              longitude: -180
            },
            number: 100,
            generateProperties: function(store) {
              return {};
            }
          },
          addtionalStoreProperties: {},
          iconPath: '/webAsset/image/storeLocator/',

          /*
              Specifies a fallback marker icon (if no store specific icon
              was set). If set to "null" google will place a fallback
              icon.
           */
          defaultMarkerIconFileName: null,

          /*
              If not provided we initialize the map with center in
              current location determined by internet protocol address.
           */
          startLocation: null,
          fallbackLocation: {
            latitude: 51.124213,
            longitude: 10.147705
          },

          /*
              Current ip. If set to "null" ip will be determined
              dynamically
           */
          ip: null,
          ipToLocation: {

            /*
                IP to location determination application interface url.
                {1} and {2} represents currently used protocol and
                potentially given ip.
             */
            applicationInterfaceURL: '{1}://freegeoip.net/json/{2}',

            /*
                Time to wait for ip resolve. If time is up initialize
                on given fallback location.
             */
            timeoutInMilliseconds: 5000,

            /*
                Defines bound withing determined locations should be.
                If resolved location isn't within this location it will
                be ignored.
             */
            bounds: {
              northEast: {
                latitude: 85,
                longitude: 180
              },
              southWest: {
                latitude: -85,
                longitude: -180
              }
            }
          },
          map: {
            zoom: 3
          },
          showInputAfterLoadedDelayInMilliseconds: 500,
          inputFadeInOption: {
            duration: 'fast'
          },

          /*
              Distance to move if stores are determined with same
              latitude and longitude.
           */
          distanceToMoveByDuplicatedEntries: 0.0001,
          markerCluster: {
            gridSize: 100,
            maxZoom: 11
          },

          /*
              Specifies a zoom value wich will be adjusted after
              successfully picked a search result. If set to "null" no
              zoom change happens.
           */
          successfulSearchZoom: 12,
          infoWindow: {

            /*
                Function or string returning or representing the info
                box. If a function is given and a promise is returned
                the info box will be filled with the given loading
                content and updated with the resolved data. The
                function becomes the corresponding marker as first
                argument and the store locator instance as second
                argument. If nothing is provided all available data
                will be listed in a generic info window.
             */
            content: null,

            /*
                Additional move to bottom relative to the marker if an
                info window has been opened.
             */
            additionalMoveToBottomInPixel: 120,

            /*
                Content to show in the info window during info window
                load.
             */
            loadingContent: '<div class="idle">loading...</div>'
          },

          /*
              If a number is given a generic search will be provided and
              given number will be interpret as search result precision
              tolerance to identify a marker as search result. If an
              object is given it indicates what should be search for. The
              object can hold up to nine keys. "properties" to specify
              which store data should contain given search text,
              "maximumNumberOfResults" to limit the auto complete result,
              "loadingContent" to display while the results are loading,
              "numberOfAdditionalGenericPlaces" a tuple describing a
              range of minimal to maximal limits of additional generic
              google suggestions depending on number of local search
              results, "maximalDistanceInMeter" to specify maximal
              distance from current position to search suggestions,
              "genericPlaceFilter" specifies a function which gets a
              relevant place to decide if the place should be included
              (returns a boolean value), "prefereGenericResults"
              specifies a boolean value indicating if generic search
              results should be the first results,
              "genericPlaceSearchOptions" specifies how a generic place
              search should be done (google maps request object
              specification) and "content" to render the search results.
              "content" can be a function or string returning or
              representing the search results. If a function is given and
              a promise is returned the info box will be filled with the
              given loading content and updated with the resolved data.
              The function becomes search results as first argument, a
              boolean value as second argument indicating if the maximum
              number of search results was reached and the store locator
              instance as third argument. If nothing is provided all
              available data will be listed in a generic info window.
           */
          searchBox: 50,
          onLoaded: $.noop,
          onInfoWindowOpen: $.noop,
          onInfoWindowOpened: $.noop,
          onAddSearchResults: $.noop,
          onRemoveSearchResults: $.noop,
          onOpenSearchResults: $.noop,
          onCloseSearchResults: $.noop,
          onMarkerHighlighted: $.noop
        };
        StoreLocator.__super__.initialize.call(this, options);
        this.$domNodes = this.grabDomNode(this._options.domNode);
        if (this._options.startLocation != null) {
          this.initializeMap();
        } else {
          this._options.startLocation = this._options.fallbackLocation;
          loaded = false;
          window.setTimeout(((function(_this) {
            return function() {
              if (!loaded) {
                loaded = true;
                return _this.initializeMap();
              }
            };
          })(this)), this._options.ipToLocation.timeoutInMilliseconds);
          $.ajax({
            url: this.stringFormat(this._options.ipToLocation.applicationInterfaceURL, document.location.protocol.substring(0, document.location.protocol.length - 1), this._options.ip || ''),
            dataType: 'jsonp',
            cache: true
          }).always((function(_this) {
            return function(currentLocation, textStatus) {
              if (!loaded) {
                loaded = true;
                if (textStatus === 'success') {
                  if ((_this._options.ipToLocation.bounds == null) || (new window.google.maps.LatLngBounds(new window.google.maps.LatLng(_this._options.ipToLocation.bounds.southWest.latitude, _this._options.ipToLocation.bounds.southWest.longitude), new window.google.maps.LatLng(_this._options.ipToLocation.bounds.northEast.latitude, _this._options.ipToLocation.bounds.northEast.longitude))).contains(new window.google.maps.LatLng(currentLocation.latitude, currentLocation.longitude))) {
                    _this._options.startLocation = currentLocation;
                  }
                }
                return _this.initializeMap();
              }
            };
          })(this));
        }
        return this.$domNode || this;
      };

      StoreLocator.prototype.initializeMap = function() {

        /*Initializes cluster, info windows and marker. */
        var index, markerCluster, northEast, southWest, store, _i, _j, _len, _ref, _ref1;
        this._options.map.center = new window.google.maps.LatLng(this._options.startLocation.latitude, this._options.startLocation.longitude);
        this.map = new window.google.maps.Map($('<div>').appendTo(this.$domNode)[0], this._options.map);
        markerCluster = new window.MarkerClusterer(this.map, [], this._options.markerCluster);
        if ($.isArray(this._options.stores)) {
          _ref = this._options.stores;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            store = _ref[_i];
            $.extend(true, store, this._options.addtionalStoreProperties);
            markerCluster.addMarker(this.createMarker(store));
          }
        } else if ($.type(this._options.stores) === 'string') {
          $.getJSON(this._options.stores, (function(_this) {
            return function(stores) {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = stores.length; _j < _len1; _j++) {
                store = stores[_j];
                $.extend(true, store, _this._options.addtionalStoreProperties);
                _results.push(markerCluster.addMarker(_this.createMarker(store)));
              }
              return _results;
            };
          })(this));
        } else {
          southWest = new window.google.maps.LatLng(this._options.stores.southWest.latitude, this._options.stores.southWest.longitude);
          northEast = new window.google.maps.LatLng(this._options.stores.northEast.latitude, this._options.stores.northEast.longitude);
          for (index = _j = 0, _ref1 = this._options.stores.number; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; index = 0 <= _ref1 ? ++_j : --_j) {
            store = $.extend({
              latitude: southWest.lat() + (northEast.lat() - southWest.lat()) * window.Math.random(),
              longitude: southWest.lng() + (northEast.lng() - southWest.lng()) * window.Math.random()
            }, this._options.addtionalStoreProperties);
            markerCluster.addMarker(this.createMarker($.extend(store, this._options.stores.generateProperties(store))));
          }
        }
        this.map.controls[window.google.maps.ControlPosition.TOP_LEFT].push(this.$domNode.find('input')[0]);
        if ($.type(this._options.searchBox) === 'number') {
          this.initializeGenericSearchBox();
        } else {
          window.google.maps.event.addListener(this.map, 'click', (function(_this) {
            return function() {
              return _this.closeSearchResults();
            };
          })(this));
          window.google.maps.event.addListener(this.map, 'dragstart', (function(_this) {
            return function() {
              return _this.closeSearchResults();
            };
          })(this));
          this._options.searchBox = $.extend(true, {
            maximumNumberOfResults: 50,
            numberOfAdditionalGenericPlaces: [2, 5],
            maximalDistanceInMeter: 1000000,
            loadingContent: this._options.infoWindow.loadingContent,
            genericPlaceFilter: function(place) {
              return place.formatted_address.indexOf(' Deutschland') !== -1 || place.formatted_address.indexOf(' Germany') !== -1;
            },
            prefereGenericResults: true,
            genericPlaceSearchOptions: {
              radius: '50000',
              types: ['locality', 'political', 'postal_code']
            }
          }, this._options.searchBox);
          this.initializeDataSourceSearchBox();
        }
        google.maps.event.addListener(this.map, 'zoom_changed', (function(_this) {
          return function() {
            if ((_this.currentlyOpenWindow != null) && _this.currentlyOpenWindow.isOpen && _this.map.getZoom() <= _this._options.markerCluster.maxZoom) {
              _this.currentlyOpenWindow.close();
              return _this.currentlyOpenWindow.isOpen = false;
            }
          };
        })(this));
        this.fireEvent('loaded');
        return this;
      };

      StoreLocator.prototype.initializeDataSourceSearchResultsBox = function() {

        /*Position search results right below the search input field. */
        var cssProperties, propertyName, _i, _len, _ref;
        cssProperties = {};
        _ref = ['position', 'width', 'top', 'left', 'border'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          propertyName = _ref[_i];
          cssProperties[propertyName] = this.$domNode.find('input').css(propertyName);
        }
        cssProperties.marginTop = this.$domNode.find('input').outerHeight(true);
        this.resultsDomNode = $('<div>').addClass(this.stringCamelCaseToDelimited(this.__name__ + "SearchResults")).css(cssProperties);
        return this.$domNode.find('input').after(this.resultsDomNode);
      };

      StoreLocator.prototype.initializeDataSourceSearchBox = function() {

        /*
            Initializes a data source based search box to open and focus
            them matching marker.
         */
        this.on(this.$domNode, 'keydown', (function(_this) {
          return function(event) {
            var currentIndex;
            if (_this.currentSearchResults.length) {
              if (_this.currentSearchResultRange) {
                _this.currentSearchResultRange = [window.Math.max(0, _this.currentSearchResultRange[0]), window.Math.min(_this.currentSearchResults.length - 1, _this.currentSearchResultRange[1])];
              } else {
                _this.currentSearchResultRange = [0, _this.currentSearchResults.length - 1];
              }
              currentIndex = _this.currentSearchResults.indexOf(_this.currentlyHighlightedMarker);
              if (event.keyCode === _this.keyCode.DOWN) {
                if (currentIndex === -1 || _this.currentSearchResultRange[1] < currentIndex + 1) {
                  return _this.highlightMarker(null, _this.highlightMarker, _this.currentSearchResults[_this.currentSearchResultRange[0]], event);
                } else {
                  return _this.highlightMarker(null, _this.highlightMarker, _this.currentSearchResults[currentIndex + 1], event);
                }
              } else if (event.keyCode === _this.keyCode.UP) {
                if (currentIndex === _this.currentSearchResultRange[0] || currentIndex === (-1)) {
                  return _this.highlightMarker(null, _this.highlightMarker, _this.currentSearchResults[_this.currentSearchResultRange[1]], event);
                } else {
                  return _this.highlightMarker(null, _this.highlightMarker, _this.currentSearchResults[currentIndex - 1], event);
                }
              } else if (event.keyCode === _this.keyCode.ENTER && _this.currentlyHighlightedMarker) {
                event.stopPropagation();
                if (_this.currentlyHighlightedMarker.infoWindow) {
                  return _this.openMarker(null, _this.openMarker, _this.currentlyHighlightedMarker, event);
                } else {
                  return _this.openPlace(_this.currentlyHighlightedMarker.data, _this.openPlace, event);
                }
              }
            }
          };
        })(this));
        this.on(this.$domNode.find('input'), 'focus', (function(_this) {
          return function() {
            if (_this.currentSearchText) {
              return _this.openSearchResults();
            }
          };
        })(this));
        this.on(this.$domNode.find('input'), 'keydown', (function(_this) {
          return function(event) {
            var keyCode, name, _ref;
            _ref = _this.keyCode;
            for (name in _ref) {
              keyCode = _ref[name];
              if (event.keyCode === keyCode && (name !== 'DOWN')) {
                return;
              }
            }
            if (_this.currentSearchText) {
              return _this.openSearchResults();
            }
          };
        })(this));
        this.on(this.$domNode.find('input'), 'click', (function(_this) {
          return function() {
            if (_this.currentSearchText) {
              return _this.openSearchResults();
            }
          };
        })(this));
        window.google.maps.event.addListener(this.map, 'center_changed', (function(_this) {
          return function() {
            if (_this.currentSearchText && (_this.resultsDomNode != null)) {
              return _this.searchResultsDirty = true;
            }
          };
        })(this));
        this.on(this.$domNode.find('input'), 'keyup', this.getUpdateSearchResultsHandler());
        return this;
      };

      StoreLocator.prototype.getUpdateSearchResultsHandler = function() {
        var placesService;
        placesService = new google.maps.places.PlacesService(this.map);
        return this.debounce(((function(_this) {
          return function(event) {
            var keyCode, name, _ref;
            _ref = _this.keyCode;
            for (name in _ref) {
              keyCode = _ref[name];
              if ((event != null ? event.keyCode : void 0) === keyCode && (name !== 'DELETE' && name !== 'BACKSPACE')) {
                return;
              }
            }
            return _this.acquireLock(_this.__name__ + "Search", function() {
              var loadingDomNode, searchText, _ref1;
              searchText = $.trim(_this.$domNode.find('input').val());
              if (_this.currentSearchText === searchText && !_this.searchResultsDirty) {
                return _this.releaseLock(_this.__name__ + "Search");
              }
              _this.searchResultsDirty = false;
              if (!_this.resultsDomNode) {
                _this.initializeDataSourceSearchResultsBox();
              }
              if (!searchText) {
                _this.currentSearchText = '';
                _this.currentSearchResults = [];
                _this.resultsDomNode.html('');
                _this.currentSearchResultsDomNode = null;
                _this.closeSearchResults();
                return _this.releaseLock(_this.__name__ + "Search");
              }
              _this.openSearchResults();
              loadingDomNode = $(_this._options.searchBox.loadingContent);
              if (!_this.fireEvent('addSearchResults', false, _this, loadingDomNode, _this.resultsDomNode, _this.currentSearchResultsDomNode || [])) {
                _this.resultsDomNode.html(loadingDomNode);
              }
              if ((_ref1 = _this.currentSearchResultsDomNode) != null ? _ref1.length : void 0) {
                _this.fireEvent('removeSearchResults', false, _this, _this.currentSearchResultsDomNode);
              }
              _this.currentSearchResultsDomNode = loadingDomNode;
              if (_this._options.searchBox.numberOfAdditionalGenericPlaces) {
                return placesService.textSearch($.extend({
                  query: searchText,
                  location: _this.map.getCenter()
                }, _this._options.searchBox.genericPlaceSearchOptions), function(places) {
                  if (places) {
                    return _this.handleGenericSearchResults(places, searchText);
                  }
                });
              } else {
                return _this.performLocalSearch(searchText);
              }
            });
          };
        })(this)), 1000);
      };

      StoreLocator.prototype.handleGenericSearchResults = function(places, searchText) {

        /*Sorts and filters search results given by the google api. */
        var distance, index, place, result, searchResults, _i, _len, _ref;
        searchResults = [];
        index = 1;
        _ref = places.sort((function(_this) {
          return function(firstPlace, secondPlace) {
            return window.google.maps.geometry.spherical.computeDistanceBetween(_this.map.getCenter(), firstPlace.geometry.location) - window.google.maps.geometry.spherical.computeDistanceBetween(_this.map.getCenter(), secondPlace.geometry.location);
          };
        })(this));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          place = _ref[_i];
          index += 1;
          distance = window.google.maps.geometry.spherical.computeDistanceBetween(this.map.getCenter(), place.geometry.location);
          if (distance > this._options.searchBox.maximalDistanceInMeter) {
            break;
          }
          if (this._options.searchBox.genericPlaceFilter(place)) {
            result = {
              data: $.extend(place, {
                logoFilePath: place.icon.replace(/^http:(\/\/)/, document.location.protocol + "$1"),
                address: place.formatted_address,
                distance: distance
              }),
              position: place.geometry.location,
              open: (function(_this) {
                return function(place) {
                  return function(event) {
                    return _this.openPlace(place, _this.openPlace, event);
                  };
                };
              })(this)(place),
              highlight: function(event, type) {
                return this.isHighlighted = type !== 'stop';
              }
            };
            searchResults.push(result);
            if (this._options.searchBox.numberOfAdditionalGenericPlaces[1] < index) {
              break;
            }
          }
        }
        return this.performLocalSearch(searchText, searchResults);
      };

      StoreLocator.prototype.performLocalSearch = function(searchText, searchResults) {
        var key, limitReached, marker, numberOfGenericSearchResults, resultsRepresentation, resultsRepresentationDomNode, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        if (searchResults == null) {
          searchResults = [];
        }

        /*Performs a search on locally given store data. */
        numberOfGenericSearchResults = searchResults.length;
        _ref = this.markers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          marker = _ref[_i];
          _ref1 = this._options.searchBox.properties;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            key = _ref1[_j];
            if ((marker.data[key] || marker.data[key] === 0) && ("" + marker.data[key]).toLowerCase().replace(/[-_&]+/g, ' ').indexOf(searchText.toLowerCase().replace(/[-_&]+/g, ' ')) !== -1) {
              (function(_this) {
                return (function(marker) {
                  marker.open = function(event) {
                    return _this.openMarker(null, _this.openMarker, marker, event);
                  };
                  return marker.highlight = function(event, type) {
                    return _this.highlightMarker(null, _this.highlightMarker, marker, event, type);
                  };
                });
              })(this)(marker);
              searchResults.push(marker);
              break;
            }
          }
        }
        if (this._options.searchBox.numberOfAdditionalGenericPlaces) {
          if (searchResults.length && numberOfGenericSearchResults > this._options.searchBox.numberOfAdditionalGenericPlaces[0]) {
            if (searchResults.length > this._options.searchBox.numberOfAdditionalGenericPlaces[1]) {
              searchResults.splice(this._options.searchBox.numberOfAdditionalGenericPlaces[0], numberOfGenericSearchResults - this._options.searchBox.numberOfAdditionalGenericPlaces[0]);
            }
          }
        }
        limitReached = false;
        if (this._options.searchBox.maximumNumberOfResults < searchResults.length) {
          limitReached = true;
          searchResults.splice(this._options.searchBox.maximumNumberOfResults, searchResults.length);
        }
        searchResults.sort((function(_this) {
          return function(first, second) {
            if (_this._options.searchBox.prefereGenericResults && !first.infoWindow && second.infoWindow) {
              return -1;
            }
            if (_this._options.searchBox.prefereGenericResults && !second.infoWindow && first.infoWindow) {
              return +1;
            }
            return window.google.maps.geometry.spherical.computeDistanceBetween(_this.map.getCenter(), first.position) - window.google.maps.geometry.spherical.computeDistanceBetween(_this.map.getCenter(), second.position);
          };
        })(this));
        resultsRepresentation = this.makeSearchResults(searchResults, limitReached);
        if ($.type(resultsRepresentation) === 'string') {
          resultsRepresentationDomNode = $(resultsRepresentation);
          if (!this.fireEvent('addSearchResults', false, this, resultsRepresentationDomNode, this.resultsDomNode, this.currentSearchResultsDomNode || [])) {
            this.resultsDomNode.html(resultsRepresentationDomNode);
          }
          if ((_ref2 = this.currentSearchResultsDomNode) != null ? _ref2.length : void 0) {
            this.fireEvent('removeSearchResults', false, this, this.currentSearchResultsDomNode);
          }
          this.currentSearchResultsDomNode = resultsRepresentationDomNode;
          window.setTimeout((function(_this) {
            return function() {
              return _this.releaseLock(_this.__name__ + "Search");
            };
          })(this));
        } else {
          resultsRepresentation.then((function(_this) {
            return function(resultsRepresentation) {
              var _ref3;
              resultsRepresentationDomNode = $(resultsRepresentation);
              if (!_this.fireEvent('addSearchResults', false, _this, resultsRepresentationDomNode, _this.resultsDomNode, _this.currentSearchResultsDomNode || [])) {
                _this.resultsDomNode.html(resultsRepresentationDomNode);
              }
              if ((_ref3 = _this.currentSearchResultsDomNode) != null ? _ref3.length : void 0) {
                _this.fireEvent('removeSearchResults', false, _this, _this.currentSearchResultsDomNode);
              }
              _this.currentSearchResultsDomNode = resultsRepresentationDomNode;
              return _this.releaseLock(_this.__name__ + "Search");
            };
          })(this));
        }
        this.currentSearchText = searchText;
        this.currentSearchResults = searchResults.slice();
        return this;
      };

      StoreLocator.prototype.openSearchResults = function(event) {

        /*Opens current search results. */
        if (event != null) {
          event.stopPropagation();
        }
        this.getUpdateSearchResultsHandler()(event);
        if ((this.resultsDomNode != null) && !this.resultsDomNode.hasClass('open') && !this.fireEvent('openSearchResults', false, this, event, this.resultsDomNode)) {
          this.resultsDomNode.addClass('open');
        }
        return this;
      };

      StoreLocator.prototype.closeSearchResults = function(event) {

        /*Closes current search results. */
        if (event != null) {
          event.stopPropagation();
        }
        if ((this.resultsDomNode != null) && this.resultsDomNode.hasClass('open') && !this.fireEvent('closeSearchResults', false, this, event, this.resultsDomNode)) {
          this.resultsDomNode.removeClass('open');
        }
        return this;
      };

      StoreLocator.prototype.initializeGenericSearchBox = function() {

        /*
            Initializes googles generic search box and tries to match to
            open and focus them.
         */
        var searchBox;
        searchBox = new window.google.maps.places.SearchBox(this.$domNode.find('input')[0]);
        window.google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
          return function() {
            return searchBox.setBounds(_this.map.getBounds());
          };
        })(this));
        window.google.maps.event.addListener(searchBox, 'places_changed', (function(_this) {
          return function() {
            return _this.ensurePlaceLocations(searchBox.getPlaces(), function(places) {
              var distanceInMeter, foundPlace, marker, matchingMarker, shortestDistanceInMeter, _i, _len, _ref;
              foundPlace = _this.determineBestSearchResult(places);
              if (foundPlace != null) {
                shortestDistanceInMeter = window.Number.MAX_VALUE;
                matchingMarker = null;
                _ref = _this.markers;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  marker = _ref[_i];
                  distanceInMeter = window.google.maps.geometry.spherical.computeDistanceBetween(foundPlace.geometry.location, marker.position);
                  if (distanceInMeter < shortestDistanceInMeter) {
                    shortestDistanceInMeter = distanceInMeter;
                    matchingMarker = marker;
                  }
                }
                if (matchingMarker && shortestDistanceInMeter <= _this._options.searchBox) {
                  if (_this._options.successfulSearchZoom != null) {
                    _this.map.setZoom(_this._options.successfulSearchZoom);
                  }
                  return _this.openMarker(foundPlace, _this.openMarker, matchingMarker);
                }
                if (_this.currentlyOpenWindow != null) {
                  _this.currentlyOpenWindow.close();
                  _this.currentlyOpenWindow.isOpen = false;
                }
                _this.map.setCenter(foundPlace.geometry.location);
                if (_this._options.successfulSearchZoom != null) {
                  return _this.map.setZoom(_this._options.successfulSearchZoom);
                }
              }
            });
          };
        })(this));
        return this;
      };

      StoreLocator.prototype.ensurePlaceLocations = function(places, onSuccess) {

        /*Ensures that every given place have a location property. */
        var geocoder, place, runningGeocodes, _i, _len, _ref;
        runningGeocodes = 0;
        for (_i = 0, _len = places.length; _i < _len; _i++) {
          place = places[_i];
          if (((_ref = place.geometry) != null ? _ref.location : void 0) == null) {
            this.warn('Found place "{1}" doesn\'t have a location. ' + 'Full object:', place.name);
            this.warn(place);
            this.info('Geocode will be determined separately. With ' + 'address "{1}".', place.name);
            if (typeof geocoder === "undefined" || geocoder === null) {
              geocoder = new window.google.maps.Geocoder();
            }
            runningGeocodes += 1;
            geocoder.geocode({
              address: place.name
            }, function(results, status) {
              runningGeocodes -= 1;
              if (status === window.google.maps.GeocoderStatus.OK) {
                place.geometry = results[0].geometry;
              } else {
                delete places[places.indexOf(place)];
                this.warn('Found place "{1}" couldn\'t be geocoded by ', 'google. Removing it from the places list.');
              }
              if (runningGeocodes === 0) {
                return onSuccess(places);
              }
            });
          }
        }
        return this;
      };

      StoreLocator.prototype.determineBestSearchResult = function(candidates) {

        /*
            Determines the best search result from given list of
            candidates. Currently the nearest result to current viewport
            will be preferred.
         */
        var candidate, distanceInMeter, result, shortestDistanceInMeter, _i, _len;
        result = null;
        if (candidates.length) {
          shortestDistanceInMeter = window.Number.MAX_VALUE;
          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
            candidate = candidates[_i];
            distanceInMeter = window.google.maps.geometry.spherical.computeDistanceBetween(candidate.geometry.location, this.map.getCenter());
            if (distanceInMeter < shortestDistanceInMeter) {
              result = candidate;
              shortestDistanceInMeter = distanceInMeter;
            }
          }
        }
        return result;
      };

      StoreLocator.prototype.onLoaded = function() {

        /*Is triggered if the complete map ist loaded. */
        window.setTimeout(((function(_this) {
          return function() {
            return _this.$domNode.find('input').fadeIn(_this._options.inputFadeInOption);
          };
        })(this)), this._options.showInputAfterLoadedDelayInMilliseconds);
        return this;
      };

      StoreLocator.prototype.createMarker = function(store) {

        /*Registers given store to the google maps canvas. */
        var index, marker, _ref;
        index = 0;
        while (_ref = store.latitude + "-" + store.longitude, __indexOf.call(this.seenLocations, _ref) >= 0) {
          if (index % 2) {
            store.latitude += this._options.distanceToMoveByDuplicatedEntries;
          } else {
            store.longitude += this._options.distanceToMoveByDuplicatedEntries;
          }
          index += 1;
        }
        this.seenLocations.push(store.latitude + "-" + store.longitude);
        marker = {
          position: new window.google.maps.LatLng(store.latitude, store.longitude),
          map: this.map,
          data: store
        };
        if (store.markerIconFileName) {
          marker.icon = this._options.iconPath + store.markerIconFileName;
        } else if (this._options.defaultMarkerIconFileName) {
          marker.icon = this._options.iconPath + this._options.defaultMarkerIconFileName;
        }
        if (store.title) {
          marker.title = store.title;
        }
        marker.infoWindow = new window.google.maps.InfoWindow({
          content: ''
        });
        marker.infoWindow.isOpen = false;
        window.google.maps.event.addListener(marker.infoWindow, 'closeclick', function() {
          return marker.infoWindow.isOpen = false;
        });
        marker.nativeMarker = new window.google.maps.Marker(marker);
        window.google.maps.event.addListener(marker.nativeMarker, 'click', this.getMethod('openMarker', this, marker));
        this.markers.push(marker);
        return marker.nativeMarker;
      };

      StoreLocator.prototype.openMarker = function(place, thisFunction, marker, event) {

        /*
            Opens given marker info window. And closes a potential opened
            windows.
         */
        var infoWindow, _ref;
        if (event != null) {
          event.stopPropagation();
        }
        this.highlightMarker(place, this.highlightMarker, marker, event, 'stop');
        if (((_ref = this._options.markerCluster) != null ? _ref.maxZoom : void 0) && this.map.getZoom() <= this._options.markerCluster.maxZoom) {
          this.map.setZoom(this._options.markerCluster.maxZoom + 1);
        }
        this.closeSearchResults(event);
        if (this.currentlyOpenWindow === marker.infoWindow && this.currentlyOpenWindow.isOpen) {
          return this;
        }
        this.fireEvent('infoWindowOpen', marker);
        marker.refreshSize = function() {

          /*
              Simulates a content update to enforce info box size
              adjusting.
           */
          return marker.infoWindow.setContent(marker.infoWindow.getContent());
        };
        infoWindow = this.makeInfoWindow(marker);
        if ($.type(infoWindow) === 'string') {
          marker.infoWindow.setContent(infoWindow);
        } else {
          marker.infoWindow.setContent(this._options.infoWindow.loadingContent);
          infoWindow.then(function(infoWindow) {
            return marker.infoWindow.setContent(infoWindow);
          });
        }
        if (this.currentlyOpenWindow != null) {
          this.currentlyOpenWindow.close();
          this.currentlyOpenWindow.isOpen = false;
        }
        this.currentlyOpenWindow = marker.infoWindow;
        marker.infoWindow.isOpen = true;
        marker.infoWindow.open(this.map, marker.nativeMarker);
        this.map.panTo(marker.nativeMarker.position);
        this.map.panBy(0, -this._options.infoWindow.additionalMoveToBottomInPixel);
        this.fireEvent('infoWindowOpened', marker);
        return this;
      };

      StoreLocator.prototype.openPlace = function(place, thisFunction, event) {

        /*Focuses given place on map. */
        if (event != null) {
          event.stopPropagation();
        }
        this.closeSearchResults(event);
        if (this.currentlyOpenWindow != null) {
          this.currentlyOpenWindow.close();
          this.currentlyOpenWindow.isOpen = false;
        }
        this.map.setCenter(place.geometry.location);
        this.map.setZoom(this._options.successfulSearchZoom);
        return this;
      };

      StoreLocator.prototype.highlightMarker = function(place, thisFunction, marker, event, type) {
        var _ref, _ref1, _ref2, _ref3, _ref4;
        if (type == null) {
          type = 'bounce';
        }

        /*
            Opens given marker info window. And closes a potential opened
            windows.
         */
        if (event != null) {
          event.stopPropagation();
        }
        if (this.currentlyHighlightedMarker) {
          if ((_ref = this.currentlyHighlightedMarker.nativeMarker) != null) {
            _ref.setAnimation(null);
          }
          this.currentlyHighlightedMarker.isHighlighted = false;
          this.currentlyHighlightedMarker = null;
        }
        if (type === 'stop') {
          if ((_ref1 = marker.nativeMarker) != null) {
            _ref1.setAnimation(null);
          }
        } else {
          if (((_ref2 = this._options.markerCluster) != null ? _ref2.maxZoom : void 0) && this.map.getZoom() <= this._options.markerCluster.maxZoom && (((_ref3 = marker.nativeMarker) != null ? _ref3.position : void 0) != null) && this.map.getBounds().contains(marker.nativeMarker.position)) {
            this.map.setCenter(marker.nativeMarker.position);
            this.map.setZoom(this._options.markerCluster.maxZoom + 1);
          }
          if (marker !== this.currentlyHighlightedMarker) {
            if ((_ref4 = marker.nativeMarker) != null) {
              _ref4.setAnimation(window.google.maps.Animation[type.toUpperCase()]);
            }
            marker.isHighlighted = true;
            this.currentlyHighlightedMarker = marker;
          }
          this.fireEvent('markerHighlighted', marker);
        }
        return this;
      };

      StoreLocator.prototype.makeInfoWindow = function(marker) {

        /*
            Takes the marker for a store and creates the HTML content of
            the info window.
         */
        var content, name, value, _ref;
        if ($.isFunction(this._options.infoWindow.content)) {
          return this._options.infoWindow.content.apply(this, arguments);
        }
        if (this._options.infoWindow.content != null) {
          return this._options.infoWindow.content;
        }
        content = '<div>';
        _ref = marker.data;
        for (name in _ref) {
          value = _ref[name];
          content += name + ": " + value + "<br />";
        }
        return content + "</div>";
      };

      StoreLocator.prototype.makeSearchResults = function(searchResults) {

        /*
            Takes the search results and creates the HTML content of the
            search results.
         */
        var content, name, result, value, _i, _len, _ref;
        if ($.isFunction(this._options.searchBox.content)) {
          return this._options.searchBox.content.apply(this, arguments);
        }
        if (this._options.searchBox.content != null) {
          return this._options.searchBox.content;
        }
        content = '';
        for (_i = 0, _len = searchResults.length; _i < _len; _i++) {
          result = searchResults[_i];
          content += '<div>';
          _ref = result.data;
          for (name in _ref) {
            value = _ref[name];
            content += name + ": " + value + "<br />";
          }
          content += '</div>';
        }
        return content;
      };

      return StoreLocator;

    })($.Tools["class"]);
    return $.fn.StoreLocator = function() {
      return $.Tools().controller(StoreLocator, arguments, this);
    };
  };

  if (this.require != null) {
    this.require.scopeIndicator = 'jQuery.fn.StoreLocator';
    this.require([['jQuery.Tools', 'jquery-tools-1.0.coffee']], main);
  } else {
    main(this.jQuery);
  }

}).call(this);
