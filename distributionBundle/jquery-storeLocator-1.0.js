// Generated by CoffeeScript 1.9.0

/*
[Project page](https://thaibault.github.com/jQuery-storeLocator)

This plugin provides a google application interface based store locator.

Copyright Torben Sickert 16.12.2012

License
-------

This library written by Torben Sickert stand under a creative commons naming
3.0 unported license. see http://creativecommons.org/licenses/by/3.0/deed.de

Extending this module
---------------------

For conventions see require on https://github.com/thaibault/require

Author
------

t.sickert["~at~"]gmail.com (Torben Sickert)

Version
-------

1.0 stable
 */

(function() {
  var main,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  main = function($) {
    var StoreLocator;
    StoreLocator = (function(_super) {
      __extends(StoreLocator, _super);

      function StoreLocator() {
        return StoreLocator.__super__.constructor.apply(this, arguments);
      }


      /*
          A jQuery storelocator plugin.
      
          Expected store data format:
      
          {latitude: NUMBER, longitude: NUMBER, markerIconFileName: STRING}
       */

      StoreLocator.prototype.__name__ = 'StoreLocator';

      StoreLocator.prototype.initialize = function(options) {
        if (options == null) {
          options = {};
        }

        /*Entry point for object orientated jQuery plugin. */
        this.resultsDomNode = null;
        this.currentlyOpenWindow = null;
        this.seenLocations = [];
        this.markers = [];
        this._options = {

          /*
              URL to retrieve stores, list of stores or object describing
              bounds to create random stores within. If a
              "generateProperties" function is given it will be called to
              retrieve additional properties for each store. The
              specified store will be given to the function.
           */
          stores: {
            northEast: {
              latitude: 85,
              longitude: 180
            },
            southWest: {
              latitude: -85,
              longitude: -180
            },
            number: 100,
            generateProperties: function(store) {
              return {};
            }
          },
          addtionalStoreProperties: {},
          iconPath: '/webAsset/image/storeLocator/',

          /*
              Specifies a fallback marker icon (if no store specific icon
              was set). If set to "null" google will place a fallback
              icon.
           */
          defaultMarkerIconFileName: null,

          /*
              If not provided we initialize the map with center in
              current location determined by internet protocol address.
           */
          startLocation: null,
          fallbackLocation: {
            latitude: 51.124213,
            longitude: 10.147705
          },

          /*
              Current ip. If set to "null" ip will be determined
              dynamically
           */
          ip: null,
          ipToLocation: {

            /*
                IP to location determination application interface url.
                {1} and {2} represents currently used protocol and
                potentially given ip.
             */
            applicationInterfaceURL: '{1}://freegeoip.net/json/{2}',

            /*
                Time to wait for ip resolve. If time is up initialize
                on given fallback location.
             */
            timeoutInMilliseconds: 5000
          },
          map: {
            zoom: 3
          },
          showInputAfterLoadedDelayInMilliseconds: 500,
          inputFadeInOption: {
            duration: 'fast'
          },

          /*
              Distance to move if stores are determined with same
              latitude and longitude.
           */
          distanceToMoveByDuplicatedEntries: 0.0001,
          markerCluster: {
            gridSize: 100,
            maxZoom: 11
          },

          /*
              Specifies a zoom value wich will be adjusted after
              successfully picked a search result. If set to "null" no
              zoom change happens.
           */
          successfulSearchZoom: 12,
          infoWindow: {

            /*
                Function or string returning or representing the info
                box. If a function is given and a promise is returned
                the info box will be filled with the given loading
                content and updated with the resolved data. The
                function becomes the corresponding marker as first
                argument and the store locator instance as second
                argument. If nothing is provided all available data
                will be listed in a generic info window.
             */
            content: null,

            /*
                Additional move to bottom relative to the marker if an
                info window has been opened.
             */
            additionalMoveToBottomInPixel: 100,

            /*
                Content to show in the info window during info window
                load.
             */
            loadingContent: 'loading...'
          },
          onLoaded: $.noop,
          onInfoWindowOpen: $.noop,
          onInfoWindowOpened: $.noop,

          /*
              If a number is given a generic search will be provided and
              given number will be interpret as search result precision
              tolerance to identify a marker as search result.
              If an object is given it indicates what should be search
              for. The object can hold four keys. "properties" to
              specify which store data should contain given search text,
              "maximumNumberOfResults" to limit the auto complete result,
              "loadingContent" to display while the results are loading
              and "content" to render the search results. "content" can
              be a function or string returning or representing the
              search results. If a function is given and a promise is
              returned the info box will be filled with the given loading
              content and updated with the resolved data. The function
              becomes search results as first argument, a boolean
              value as second argument indicating if the maximum number
              of search results was reached and the store locator
              instance as third argument. If nothing is provided all
              available data will be listed in a generic info window.
           */
          searchBox: 50
        };
        StoreLocator.__super__.initialize.call(this, options);
        this.$domNodes = this.grabDomNode(this._options.domNode);
        if (this._options.startLocation != null) {
          this.initializeMap();
        } else {
          this._options.startLocation = this._options.fallbackLocation;
          $.ajax({
            url: this.stringFormat(this._options.ipToLocation.applicationInterfaceURL, document.location.protocol.substring(0, document.location.protocol.length - 1), this._options.ip || ''),
            timeout: this._options.ipToLocation.timeoutInMilliseconds,
            dataType: 'jsonp'
          }).done((function(_this) {
            return function(currentLocation) {
              return _this._options.startLocation = currentLocation;
            };
          })(this)).always((function(_this) {
            return function() {
              return _this.initializeMap();
            };
          })(this));
        }
        return this.$domNode || this;
      };

      StoreLocator.prototype.initializeMap = function() {

        /*Initializes cluster, info windows and marker. */
        var index, markerCluster, northEast, searchInputDomNode, southWest, store, _i, _j, _len, _ref, _ref1;
        this._options.map.center = new window.google.maps.LatLng(this._options.startLocation.latitude, this._options.startLocation.longitude);
        this.map = new window.google.maps.Map($('<div>').appendTo(this.$domNode)[0], this._options.map);
        markerCluster = new window.MarkerClusterer(this.map, [], this._options.markerCluster);
        if ($.isArray(this._options.stores)) {
          _ref = this._options.stores;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            store = _ref[_i];
            $.extend(true, store, this._options.addtionalStoreProperties);
            markerCluster.addMarker(this.createMarker(store));
          }
        } else if ($.type(this._options.stores) === 'string') {
          $.getJSON(this._options.stores, (function(_this) {
            return function(stores) {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = stores.length; _j < _len1; _j++) {
                store = stores[_j];
                $.extend(true, store, _this._options.addtionalStoreProperties);
                _results.push(markerCluster.addMarker(_this.createMarker(store)));
              }
              return _results;
            };
          })(this));
        } else {
          southWest = new window.google.maps.LatLng(this._options.stores.southWest.latitude, this._options.stores.southWest.longitude);
          northEast = new window.google.maps.LatLng(this._options.stores.northEast.latitude, this._options.stores.northEast.longitude);
          for (index = _j = 0, _ref1 = this._options.stores.number; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; index = 0 <= _ref1 ? ++_j : --_j) {
            store = $.extend({
              latitude: southWest.lat() + (northEast.lat() - southWest.lat()) * window.Math.random(),
              longitude: southWest.lng() + (northEast.lng() - southWest.lng()) * window.Math.random()
            }, this._options.addtionalStoreProperties);
            markerCluster.addMarker(this.createMarker($.extend(store, this._options.stores.generateProperties(store))));
          }
        }
        searchInputDomNode = this.$domNode.find('input');
        this.map.controls[window.google.maps.ControlPosition.TOP_LEFT].push(searchInputDomNode[0]);
        if ($.type(this._options.searchBox) === 'number') {
          this.initializeGenericSearchBox(searchInputDomNode);
        } else {
          this._options.searchBox = $.extend({
            maximumNumberOfResults: 50,
            loadingContent: this._options.infoWindow.loadingContent
          }, this._options.searchBox);
          this.initializeDataSourceSearchBox(searchInputDomNode);
        }
        this.fireEvent('loaded');
        return this;
      };

      StoreLocator.prototype.initializeDataSourceSearchBox = function(searchInputDomNode) {

        /*
            Initializes a data source based search box to open and focus
            them matching marker.
         */
        this.on(searchInputDomNode, 'keyup', (function(_this) {
          return function() {
            var cssProperties, key, limitReached, marker, propertyName, resultsDomNode, resultsRepresentation, searchResults, searchText, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
            searchResults = [];
            searchText = searchInputDomNode.val();
            limitReached = false;
            _ref = _this.markers;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              marker = _ref[_i];
              _ref1 = _this._options.searchBox.properties;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                key = _ref1[_j];
                if ((marker.data[key] || marker.data[key] === 0) && ("" + marker.data[key]).toLowerCase().indexOf(searchText.toLowerCase()) !== -1) {
                  if (searchResults.length === _this._options.searchBox.maximumNumberOfResults) {
                    limitReached = true;
                    break;
                  }
                  (function(marker) {
                    return marker.open = function() {
                      return _this.openMarker(null, _this.openMarker, marker);
                    };
                  })(marker);
                  searchResults.push(marker);
                  break;
                }
              }
              if (limitReached) {
                break;
              }
            }
            _this.closeSearchResults();
            cssProperties = {};
            _ref2 = ['position', 'width', 'top', 'left', 'border'];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              propertyName = _ref2[_k];
              cssProperties[propertyName] = searchInputDomNode.css(propertyName);
            }
            cssProperties.marginTop = searchInputDomNode.outerHeight(true);
            resultsDomNode = $('<div>').css(cssProperties);
            resultsRepresentation = _this.makeSearchResults(searchResults, limitReached);
            if ($.type(resultsRepresentation) === 'string') {
              resultsDomNode.html(resultsRepresentation);
            } else {
              resultsDomNode.html(_this._options.searchBox.loadingContent);
              resultsRepresentation.then(function(resultsRepresentation) {
                return resultsDomNode.html(resultsRepresentation);
              });
            }
            searchInputDomNode.after(resultsDomNode);
            return _this.resultsDomNode = resultsDomNode;
          };
        })(this));
        return this;
      };

      StoreLocator.prototype.closeSearchResults = function(event) {
        if (event != null) {
          event.stopPropagation();
        }
        if (this.resultsDomNode) {
          this.resultsDomNode.remove();
          this.resultsDomNode = null;
        }
        return this;
      };

      StoreLocator.prototype.initializeGenericSearchBox = function(searchInputDomNode) {

        /*
            Initializes googles generic search box and tries to match to
            open and focus them.
         */
        var searchBox;
        searchBox = new window.google.maps.places.SearchBox(searchInputDomNode[0]);
        window.google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
          return function() {
            return searchBox.setBounds(_this.map.getBounds());
          };
        })(this));
        window.google.maps.event.addListener(searchBox, 'places_changed', (function(_this) {
          return function() {
            return _this.ensurePlaceLocations(searchBox.getPlaces(), function(places) {
              var distanceInMeter, foundPlace, marker, matchingMarker, shortestDistanceInMeter, _i, _len, _ref;
              foundPlace = _this.determineBestSearchResult(places);
              if (foundPlace != null) {
                shortestDistanceInMeter = window.Number.MAX_VALUE;
                matchingMarker = null;
                _ref = _this.markers;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  marker = _ref[_i];
                  distanceInMeter = window.google.maps.geometry.spherical.computeDistanceBetween(foundPlace.geometry.location, marker.position);
                  if (distanceInMeter < shortestDistanceInMeter) {
                    shortestDistanceInMeter = distanceInMeter;
                    matchingMarker = marker;
                  }
                }
                if (matchingMarker && shortestDistanceInMeter <= _this._options.searchBox) {
                  if (_this._options.successfulSearchZoom != null) {
                    _this.map.setZoom(_this._options.successfulSearchZoom);
                  }
                  return _this.openMarker(foundPlace, _this.openMarker, matchingMarker);
                }
                if (_this.currentlyOpenWindow != null) {
                  _this.currentlyOpenWindow.close();
                }
                _this.map.setCenter(foundPlace.geometry.location);
                if (_this._options.successfulSearchZoom != null) {
                  return _this.map.setZoom(_this._options.successfulSearchZoom);
                }
              }
            });
          };
        })(this));
        return this;
      };

      StoreLocator.prototype.ensurePlaceLocations = function(places, onSuccess) {

        /*Ensures that every given place have a location property. */
        var geocoder, place, runningGeocodes, _i, _len, _ref;
        runningGeocodes = 0;
        for (_i = 0, _len = places.length; _i < _len; _i++) {
          place = places[_i];
          if (((_ref = place.geometry) != null ? _ref.location : void 0) == null) {
            this.warn('Found place "{1}" doesn\'t have a location. ' + 'Full object:', place.name);
            this.warn(place);
            this.info('Geocode will be determined separately. With ' + 'address "{1}".', place.name);
            if (typeof geocoder === "undefined" || geocoder === null) {
              geocoder = new window.google.maps.Geocoder();
            }
            runningGeocodes += 1;
            geocoder.geocode({
              address: place.name
            }, function(results, status) {
              runningGeocodes -= 1;
              if (status === window.google.maps.GeocoderStatus.OK) {
                place.geometry = results[0].geometry;
              } else {
                delete places[places.indexOf(place)];
                this.warn('Found place "{1}" couldn\'t be geocoded by ', 'google. Removing it from the places list.');
              }
              if (runningGeocodes === 0) {
                return onSuccess(places);
              }
            });
          }
        }
        return this;
      };

      StoreLocator.prototype.determineBestSearchResult = function(candidates) {

        /*
            Determines the best search result from given list of
            candidates. Currently the nearest result to current viewport
            will be preferred.
         */
        var candidate, distanceInMeter, result, shortestDistanceInMeter, _i, _len;
        result = null;
        if (candidates.length) {
          shortestDistanceInMeter = window.Number.MAX_VALUE;
          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
            candidate = candidates[_i];
            distanceInMeter = window.google.maps.geometry.spherical.computeDistanceBetween(candidate.geometry.location, this.map.getCenter());
            if (distanceInMeter < shortestDistanceInMeter) {
              result = candidate;
              shortestDistanceInMeter = distanceInMeter;
            }
          }
        }
        return result;
      };

      StoreLocator.prototype.onLoaded = function() {

        /*Is triggered if the complete map ist loaded. */
        window.setTimeout(((function(_this) {
          return function() {
            return _this.$domNode.find('input').fadeIn(_this._options.inputFadeInOption);
          };
        })(this)), this._options.showInputAfterLoadedDelayInMilliseconds);
        return this;
      };

      StoreLocator.prototype.createMarker = function(store) {

        /*Registers given store to the google maps canvas. */
        var index, marker, _ref;
        index = 0;
        while (_ref = store.latitude + "-" + store.longitude, __indexOf.call(this.seenLocations, _ref) >= 0) {
          if (index % 2) {
            store.latitude += this._options.distanceToMoveByDuplicatedEntries;
          } else {
            store.longitude += this._options.distanceToMoveByDuplicatedEntries;
          }
          index += 1;
        }
        this.seenLocations.push(store.latitude + "-" + store.longitude);
        marker = {
          position: new window.google.maps.LatLng(store.latitude, store.longitude),
          map: this.map,
          data: store
        };
        if (store.markerIconFileName) {
          marker.icon = this._options.iconPath + store.markerIconFileName;
        } else if (this._options.defaultMarkerIconFileName) {
          marker.icon = this._options.iconPath + this._options.defaultMarkerIconFileName;
        }
        if (store.title) {
          marker.title = store.title;
        }
        marker.infoWindow = new window.google.maps.InfoWindow({
          content: ''
        });
        marker.googleMarker = new window.google.maps.Marker(marker);
        window.google.maps.event.addListener(marker.googleMarker, 'click', this.getMethod('openMarker', this, marker));
        this.markers.push(marker);
        return marker.googleMarker;
      };

      StoreLocator.prototype.openMarker = function(place, thisFunction, marker) {

        /*
            Opens given marker info window. And closes a potential opened
            windows.
         */
        var infoWindow;
        this.closeSearchResults();
        if (this.currentlyOpenWindow === marker.infoWindow) {
          return this;
        }
        this.fireEvent('infoWindowOpen', marker);
        marker.refreshSize = function() {

          /*
              Simulates a content update to enforce info box size
              adjusting.
           */
          return marker.infoWindow.setContent(marker.infoWindow.getContent());
        };
        infoWindow = this.makeInfoWindow(marker);
        if ($.type(infoWindow) === 'string') {
          marker.infoWindow.setContent(infoWindow);
        } else {
          marker.infoWindow.setContent(this._options.infoWindow.loadingContent);
          infoWindow.then(function(infoWindow) {
            return marker.infoWindow.setContent(infoWindow);
          });
        }
        if (this.currentlyOpenWindow != null) {
          this.currentlyOpenWindow.close();
        }
        this.currentlyOpenWindow = marker.infoWindow;
        marker.infoWindow.open(this.map, marker.googleMarker);
        this.map.panTo(marker.googleMarker.position);
        this.map.panBy(0, -this._options.infoWindow.additionalMoveToBottomInPixel);
        this.fireEvent('infoWindowOpened', marker);
        return this;
      };

      StoreLocator.prototype.makeInfoWindow = function(marker) {

        /*
            Takes the marker for a store and creates the HTML content of
            the info window.
         */
        var content, name, value, _ref;
        if ($.isFunction(this._options.infoWindow.content)) {
          return this._options.infoWindow.content.apply(this, arguments);
        }
        if (this._options.infoWindow.content != null) {
          return this._options.infoWindow.content;
        }
        content = '<div>';
        _ref = marker.data;
        for (name in _ref) {
          value = _ref[name];
          content += name + ": " + value + "<br />";
        }
        return content + "</div>";
      };

      StoreLocator.prototype.makeSearchResults = function(searchResults) {

        /*
            Takes the search results and creates the HTML content of the
            search results.
         */
        var content, name, result, value, _i, _len, _ref;
        if ($.isFunction(this._options.searchBox.content)) {
          return this._options.searchBox.content.apply(this, arguments);
        }
        if (this._options.searchBox.content != null) {
          return this._options.searchBox.content;
        }
        content = '';
        for (_i = 0, _len = searchResults.length; _i < _len; _i++) {
          result = searchResults[_i];
          content += '<div>';
          _ref = result.data;
          for (name in _ref) {
            value = _ref[name];
            content += name + ": " + value + "<br />";
          }
          content += '</div>';
        }
        return content;
      };

      return StoreLocator;

    })($.Tools["class"]);
    return $.fn.StoreLocator = function() {
      return $.Tools().controller(StoreLocator, arguments, this);
    };
  };

  if (this.require != null) {
    this.require.scopeIndicator = 'jQuery.fn.StoreLocator';
    this.require('jquery-tools-1.0.coffee', main);
  } else {
    main(this.jQuery);
  }

}).call(this);
