'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RawSource = require('webpack-sources/lib/RawSource');

var _RawSource2 = _interopRequireDefault(_RawSource);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _imagemin = require('imagemin');

var _imagemin2 = _interopRequireDefault(_imagemin);

var _imageminPngquant = require('imagemin-pngquant');

var _imageminPngquant2 = _interopRequireDefault(_imageminPngquant);

var _imageminOptipng = require('imagemin-optipng');

var _imageminOptipng2 = _interopRequireDefault(_imageminOptipng);

var _imageminGifsicle = require('imagemin-gifsicle');

var _imageminGifsicle2 = _interopRequireDefault(_imageminGifsicle);

var _imageminJpegtran = require('imagemin-jpegtran');

var _imageminJpegtran2 = _interopRequireDefault(_imageminJpegtran);

var _imageminSvgo = require('imagemin-svgo');

var _imageminSvgo2 = _interopRequireDefault(_imageminSvgo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function ImageminPlugin() {
  var _options$imageminOpti;

  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  // I love ES2015!
  var _options$disable = options.disable;
  var disable = _options$disable === undefined ? false : _options$disable;
  var _options$optipng = options.optipng;
  var optipng = _options$optipng === undefined ? {
    optimizationLevel: 3
  } : _options$optipng;
  var _options$gifsicle = options.gifsicle;
  var gifsicle = _options$gifsicle === undefined ? {
    optimizationLevel: 1
  } : _options$gifsicle;
  var _options$jpegtran = options.jpegtran;
  var jpegtran = _options$jpegtran === undefined ? {
    progressive: false
  } : _options$jpegtran;
  var _options$svgo = options.svgo;
  var svgo = _options$svgo === undefined ? {} : _options$svgo;
  var _options$pngquant = options.pngquant;
  var pngquant = _options$pngquant === undefined ? null : _options$pngquant;
  var _options$plugins = options.plugins;
  var plugins = _options$plugins === undefined ? [] : _options$plugins;


  this.options = {
    disable: disable,
    imageminOptions: {
      // Enable these by default, just pass what they give me as the options (or nothing)
      plugins: [(0, _imageminOptipng2.default)(optipng), (0, _imageminGifsicle2.default)(gifsicle), (0, _imageminJpegtran2.default)(jpegtran), (0, _imageminSvgo2.default)(svgo)]
    }
  };

  // Only enable these if they pass in options for it...
  if (pngquant !== null) this.options.imageminOptions.plugins.push((0, _imageminPngquant2.default)(pngquant));

  // And finally, add any plugins that they pass in the options to the internal plugins array
  (_options$imageminOpti = this.options.imageminOptions.plugins).push.apply(_options$imageminOpti, _toConsumableArray(plugins));
}

ImageminPlugin.prototype.apply = function (compiler) {
  var _this = this;

  // If disabled, short-circuit here and just return
  if (this.options.disable === true) return null;

  // "this-compilation" seems to be the secret plugin event that i need to grab to only get
  // everything once... I'm honestly not sure why it works, but i saw it at the below link.
  // https://github.com/webpack/compression-webpack-plugin/blob/ee8e701e47b2f488da32b135abe88a47972487de/index.js#L55
  compiler.plugin('this-compilation', function (compilation) {
    compilation.plugin('optimize-assets', function (assets, callback) {
      // Map over all assets here async and wait for all of them to complete before moving
      // Might want to look into throttling this if it overwhelms some systems...
      Promise.all((0, _map2.default)(assets, function (asset, filename) {
        // Grab the orig source and size
        var assetSource = asset.source();
        var assetOrigSize = asset.size();
        // Ensure that the contents i have are in the form of a buffer
        var assetContents = Buffer.isBuffer(assetSource) ? assetSource : new Buffer(assetSource, 'utf8');
        // push it into imagemin with the options setup up top
        return _imagemin2.default.buffer(assetContents, _this.options.imageminOptions).then(function (optimizedAssetContents) {
          // If we are bigger (or equal) after "optimization", don't touch the file...
          if (optimizedAssetContents.length >= assetOrigSize) return Promise.resolve();

          // Also not entirely sure how it works, but i got it from the below link as well as
          // looking at other webpack plugins' source code.
          // https://github.com/webpack/compression-webpack-plugin/blob/ee8e701e47b2f488da32b135abe88a47972487de/index.js#L82
          assets[filename] = new _RawSource2.default(optimizedAssetContents);
        });
      }))
      // And once everything is done, go ahead and call the callback.
      .then(function () {
        return callback();
      }).catch(function (err) {
        return callback(err);
      });
    });
  });
};

exports.default = ImageminPlugin;