#!/usr/bin/env node

// -*- coding: utf-8 -*-
'use strict';
/* !
    region header
    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by Torben Sickert stand under a creative commons naming
    3.0 unported license. see http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/
// region imports

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _child_process = require('child_process');

var _fs = require('fs');

var fileSystem = _interopRequireWildcard(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// NOTE: Only needed for debugging this file.
try {
    require('source-map-support/register');
} catch (error) {}
// endregion
// region declarations
// NOTE: This declaration isn't needed if flow knows javaScript's native
// "Proxy" in future.


// endregion
// region methods
/**
 * Provides a class of static methods with generic use cases.
 */
class Helper {
    // region boolean
    /**
     * Checks weather given object is a plain native object.
     * @param object - Object to check.
     * @returns Value "true" if given object is a plain javaScript object and
     * "false" otherwise.
     */
    static isPlainObject(object) {
        return typeof object === 'object' && object !== null && Object.getPrototypeOf(object) === Object.prototype;
    }
    /**
     * Checks weather given object is a function.
     * @param object - Object to check.
     * @returns Value "true" if given object is a function and "false"
     * otherwise.
     */
    static isFunction(object) {
        return Boolean(object) && {}.toString.call(object) === '[object Function]';
    }
    /**
     * Determines whether given file path is within given list of file
     * locations.
     * @param filePath - Path to file to check.
     * @param locationsToCheck - Locations to take into account.
     * @returns Value "true" if given file path is within one of given
     * locations or "false" otherwise.
     */
    static isFilePathInLocation(filePath, locationsToCheck) {
        for (const pathToCheck of locationsToCheck) if (_path2.default.resolve(filePath).startsWith(_path2.default.resolve(pathToCheck))) return true;
        return false;
    }
    // endregion
    /**
     * Translates given name into a valid javaScript one.
     * @param name - Name to convert.
     * @returns Converted name is returned.
     */
    static convertToValidVariableName(name) {
        return name.replace(/^[^a-zA-Z_$]+/, '').replace(/[^0-9a-zA-Z_$]+([a-zA-Z0-9])/g, (fullMatch, firstLetter) => firstLetter.toUpperCase());
    }
    /**
     * Extends given target object with given sources object. As target and
     * sources many expandable types are allowed but target and sources have to
     * to come from the same type.
     * @param targetOrDeepIndicator - Maybe the target or deep indicator.
     * @param _targetAndOrSources - Target and at least one source object.
     * @returns Returns given target extended with all given sources.
     */
    static extendObject(targetOrDeepIndicator, ..._targetAndOrSources) {
        let index = 1;
        let deep = false;
        let target;
        if (typeof targetOrDeepIndicator === 'boolean') {
            // Handle a deep copy situation and skip deep indicator and target.
            deep = targetOrDeepIndicator;
            target = arguments[1];
            index = 2;
        } else target = targetOrDeepIndicator;
        const mergeValue = (key, value, targetValue) => {
            // Recurse if we're merging plain objects or arrays.
            if (deep && value && (Array.isArray(value) || Helper.isPlainObject(value) || value instanceof Map)) {
                let clone;
                if (Array.isArray(value)) clone = targetValue && Array.isArray(targetValue) ? targetValue : [];else if (value instanceof Map) clone = targetValue && targetValue instanceof Map ? targetValue : new Map();else clone = targetValue && Helper.isPlainObject(targetValue) ? targetValue : {};
                // Never move original objects, clone them.
                return Helper.extendObject(deep, clone, value);
            }
            return value;
        };
        while (index < arguments.length) {
            const source = arguments[index];
            let targetType = typeof target;
            let sourceType = typeof source;
            if (target instanceof Map) targetType += ' Map';
            if (source instanceof Map) sourceType += ' Map';
            if (targetType !== sourceType) throw Error(`Can't merge given target type "${ targetType }" with ` + `given source type "${ sourceType }" (${ index }. argument).`);
            // Only deal with non-null/undefined values.
            if (!(source === null || source === undefined)) if (target instanceof Map && source instanceof Map) for (const [key, value] of source) {
                const newValue = mergeValue(key, value, target.get(key));
                // Don't bring in undefined values.
                if (typeof newValue !== 'undefined') target.set(key, newValue);
            } else if (target instanceof Object && source instanceof Object) for (const key in source) if (source.hasOwnProperty(key)) {
                const newValue = mergeValue(key, source[key], target[key]);
                // Don't bring in undefined values.
                if (typeof newValue !== 'undefined') target[key] = newValue;
            }
            index += 1;
        }
        return target;
    }
    /**
     * Forwards given child process communication channels to corresponding
     * current process communication channels.
     * @param childProcess - Child process meta data.
     * @returns Given child process meta data.
     */
    static handleChildProcess(childProcess) {
        childProcess.stdout.pipe(process.stdout);
        childProcess.stderr.pipe(process.stderr);
        childProcess.on('close', returnCode => {
            if (returnCode !== 0) console.error(`Task exited with error code ${ returnCode }`);
        });
        return childProcess;
    }
    /**
     * Iterates through given directory structure recursively and calls given
     * callback for each found file. Callback gets file path and corresponding
     * stat object as argument.
     * @param directoryPath - Path to directory structure to traverse.
     * @param callback - Function to invoke for each traversed file.
     * @returns Given callback function.
     */
    static walkDirectoryRecursivelySync(directoryPath, callback = (_filePath, _stat) => true) {
        fileSystem.readdirSync(directoryPath).forEach(fileName => {
            const filePath = _path2.default.resolve(directoryPath, fileName);
            const stat = fileSystem.statSync(filePath);
            if (callback(filePath, stat) !== false && stat && stat.isDirectory()) Helper.walkDirectoryRecursivelySync(filePath, callback);
        });
        return callback;
    }
    /**
     * Determines a asset type if given file.
     * @param filePath - Path to file to analyse.
     * @param buildConfiguration - Meta informations for available asset
     * types.
     * @param paths - List of paths to search if given path doesn't reference
     * a file directly.
     * @returns Determined file type or "null" of given file couldn't be
     * determined.
     */
    static determineAssetType(filePath, buildConfiguration, paths) {
        let result = null;
        for (const type in buildConfiguration) if (_path2.default.extname(filePath) === `.${ buildConfiguration[type].extension }`) {
            result = type;
            break;
        }
        if (!result) for (const type of ['source', 'target']) for (const assetType in paths.asset) if (paths.asset[assetType].startsWith(_path2.default.join(paths[type], paths.asset[assetType]))) return assetType;
        return result;
    }
    /**
     * Adds a property with a stored array of all matching file paths, which
     * matches each build configuration in given entry path and converts given
     * build configuration into a sorted array were javaScript files takes
     * precedence.
     * @param configuration - Given build configurations.
     * @param entryPath - Path to analyse nested structure.
     * @param context - Path to set paths relative to and determine relative
     * ignored paths to.
     * @param pathsToIgnore - Paths which marks location to ignore (Relative
     * paths are resolved relatively to given context.).
     * @returns Converted build configuration.
     */
    static resolveBuildConfigurationFilePaths(configuration, entryPath = './', context = './', pathsToIgnore = ['.git']) {
        const buildConfiguration = [];
        let index = 0;
        for (const type in configuration) if (configuration.hasOwnProperty(type)) {
            const newItem = Helper.extendObject(true, { filePaths: [] }, configuration[type]);
            Helper.walkDirectoryRecursivelySync(entryPath, ((index, buildConfigurationItem) => (filePath, stat) => {
                if (Helper.isFilePathInLocation(filePath, pathsToIgnore)) return false;
                if (stat.isFile() && _path2.default.extname(filePath).substring(1) === buildConfigurationItem.extension && !new RegExp(buildConfigurationItem.fileNamePattern).test(filePath)) buildConfigurationItem.filePaths.push(filePath);
            })(index, newItem));
            buildConfiguration.push(newItem);
            index += 1;
        }
        return buildConfiguration.sort((first, second) => {
            if (first.outputExtension !== second.outputExtension) {
                if (first.outputExtension === 'js') return -1;
                if (second.outputExtension === 'js') return 1;
                return first.outputExtension < second.outputExtension ? -1 : 1;
            }
            return 0;
        });
    }
    /**
     * Determines all file and directory paths related to given internal
     * modules as array.
     * @param internalInjection - List of moduleIDs or module file paths.
     * @param moduleAliases - Mapping of aliases to take into account.
     * @param knownExtensions - List of file extensions to take into account.
     * @param context - File path to resolve relative to.
     * @returns Object with a file path and directory path key mapping to
     * corresponding list of paths.
     */
    static determineModuleLocations(internalInjection, moduleAliases = {}, knownExtensions = ['.js'], context = './') {
        const filePaths = [];
        const directoryPaths = [];
        const normalizedInternalInjection = Helper.normalizeInternalInjection(internalInjection);
        for (const chunkName in normalizedInternalInjection) if (normalizedInternalInjection.hasOwnProperty(chunkName)) for (const moduleID of normalizedInternalInjection[chunkName]) {
            const filePath = Helper.determineModuleFilePath(moduleID, moduleAliases, knownExtensions, context);
            filePaths.push(filePath);
            const directoryPath = _path2.default.dirname(filePath);
            if (!directoryPaths.includes(directoryPath)) directoryPaths.push(directoryPath);
        }
        return { filePaths, directoryPaths };
    }
    /**
     * Every injection definition type can be represented as plain object
     * (mapping from chunk name to array of module ids). This method converts
     * each representation into the normalized plain object notation.
     * @param internalInjection - Given internal injection to normalize.
     * @returns Normalized representation of given internal injection.
     */
    static normalizeInternalInjection(internalInjection) {
        let result = {};
        if (internalInjection instanceof Object && Helper.isPlainObject(internalInjection)) {
            let hasContent = false;
            const chunkNamesToDelete = [];
            for (const chunkName in internalInjection) if (internalInjection.hasOwnProperty(chunkName)) if (Array.isArray(internalInjection[chunkName])) {
                if (internalInjection[chunkName].length > 0) {
                    hasContent = true;
                    result[chunkName] = internalInjection[chunkName];
                } else chunkNamesToDelete.push(chunkName);
            } else {
                hasContent = true;
                result[chunkName] = [internalInjection[chunkName]];
            }
            if (hasContent) for (const chunkName of chunkNamesToDelete) delete result[chunkName];else result = { index: [] };
        } else if (typeof internalInjection === 'string') result = { index: [internalInjection] };else if (Array.isArray(internalInjection)) result = { index: internalInjection };
        return result;
    }
    /**
     * Determines all concrete file paths for given injection which are marked
     * with the "__auto__" indicator.
     * @param givenInjection - Given internal and external injection to take
     * into account.
     * @param buildConfigurations - Resolved build configuration.
     * @param modulesToExclude - A list of modules to exclude (specified by
     * path or id) or a mapping from chunk names to module ids.
     * @param moduleAliases - Mapping of aliases to take into account.
     * @param knownExtensions - File extensions to take into account.
     * @param context - File path to use as starting point.
     * @param pathsToIgnore - Paths which marks location to ignore (Relative
     * paths are resolved relatively to given context.).
     * @returns Given injection with resolved marked indicators.
     */
    static resolveInjection(givenInjection, buildConfigurations, modulesToExclude, moduleAliases = {}, knownExtensions = ['.js', '.css', '.svg', '.html'], context = './', pathsToIgnore = ['.git']) {
        const injection = Helper.extendObject(true, {}, givenInjection);
        const moduleFilePathsToExclude = Helper.determineModuleLocations(modulesToExclude, moduleAliases, knownExtensions, context, pathsToIgnore).filePaths;
        for (const type of ['internal', 'external'])
        /* eslint-disable curly */
        if (typeof injection[type] === 'object') {
            for (const chunkName in injection[type]) if (injection[type][chunkName] === '__auto__') {
                injection[type][chunkName] = [];
                const modules = Helper.getAutoChunk(buildConfigurations, moduleFilePathsToExclude, context);
                for (const subChunkName in modules) if (modules.hasOwnProperty(subChunkName)) injection[type][chunkName].push(modules[subChunkName]);
            }
        } else if (injection[type] === '__auto__')
            /* eslint-enable curly */
            injection[type] = Helper.getAutoChunk(buildConfigurations, moduleFilePathsToExclude, context);
        return injection;
    }
    /**
     * Determines all module file paths.
     * @param buildConfigurations - Resolved build configuration.
     * @param moduleFilePathsToExclude - A list of modules file paths to
     * exclude (specified by path or id) or a mapping from chunk names to
     * module ids.
     * @param context - File path to use as starting point.
     * @returns All determined module file paths.
     */
    static getAutoChunk(buildConfigurations, moduleFilePathsToExclude, context) {
        const result = {};
        const injectedBaseNames = {};
        for (const buildConfiguration of buildConfigurations) {
            if (!injectedBaseNames[buildConfiguration.outputExtension]) injectedBaseNames[buildConfiguration.outputExtension] = [];
            for (const moduleFilePath of buildConfiguration.filePaths) if (!moduleFilePathsToExclude.includes(moduleFilePath)) {
                const baseName = _path2.default.basename(moduleFilePath, `.${ buildConfiguration.extension }`);
                /*
                    Ensure that each output type has only one source
                    representation.
                */
                if (!injectedBaseNames[buildConfiguration.outputExtension].includes(baseName)) {
                    /*
                        Ensure that if same basenames and different output
                        types can be distinguished by their extension
                        (JavaScript-Modules remains without extension since
                        they will be handled first because the build
                        configurations are expected to be sorted in this
                        context).
                    */
                    if (result[baseName]) result[_path2.default.relative(context, moduleFilePath)] = moduleFilePath;else result[baseName] = moduleFilePath;
                    injectedBaseNames[buildConfiguration.outputExtension].push(baseName);
                }
            }
        }
        return result;
    }
    /**
     * Adds dynamic getter and setter to any given data structure such as maps.
     * @param object - Object to proxy.
     * @param getterWrapper - Function to wrap each property get.
     * @param setterWrapper - Function to wrap each property set.
     * @param getterMethodName - Method name to get a stored value by key.
     * @param setterMethodName - Method name to set a stored value by key.
     * @param containesMethodName - Method name to indicate if a key is stored
     * in given data structure.
     * @param deep - Indicates to perform a deep wrapping of specified types.
     * performed via "value instanceof type".).
     * @param typesToExtend - Types which should be extended (Checks are
     * performed via "value instanceof type".).
     * @returns Returns given object wrapped with a dynamic getter proxy.
     */
    static addDynamicGetterAndSetter(object, getterWrapper = value => value, setterWrapper = (key, value) => value, getterMethodName = '[]', setterMethodName = '[]', containesMethodName = 'hasOwnProperty', deep = true, typesToExtend = [Object]) {
        if (deep) if (object instanceof Map) for (const [key, value] of object) object.set(key, Helper.addDynamicGetterAndSetter(value, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend));else if (typeof object === 'object' && object !== null) {
            for (const key in object) if (object.hasOwnProperty(key)) object[key] = Helper.addDynamicGetterAndSetter(object[key], getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);
        } else if (Array.isArray(object)) {
            let index = 0;
            for (const value of object) {
                object[index] = Helper.addDynamicGetterAndSetter(value, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);
                index += 1;
            }
        }
        for (const type of typesToExtend) if (object instanceof type) {
            if (object.__target__) return object;
            const handler = {};
            if (containesMethodName) handler.has = (target, name) => {
                if (containesMethodName === '[]') return name in target;
                return target[containesMethodName](name);
            };
            if (containesMethodName && getterMethodName) handler.get = (target, name) => {
                if (name === '__target__') return target;
                if (typeof target[name] === 'function') return target[name].bind(target);
                if (target[containesMethodName](name)) {
                    if (getterMethodName === '[]') return getterWrapper(target[name]);
                    return getterWrapper(target[getterMethodName](name));
                }
                return target[name];
            };
            if (setterMethodName) handler.set = (target, name, value) => {
                if (setterMethodName === '[]') target[name] = setterWrapper(name, value);else target[setterMethodName](name, setterWrapper(name, value));
            };
            return new Proxy(object, handler);
        }
        return object;
    }
    /**
     * Searches for nested mappings with given indicator key and resolves
     * marked values. Additionally all objects are wrapped with a proxy to
     * dynamically resolve nested properties.
     * @param object - Given mapping to resolve.
     * @param configuration - Configuration context to resolve marked values.
     * @param deep - Indicates weather to perform a recursive resolving.
     * @param evaluationIndicatorKey - Indicator property name to mark a value
     * to evaluate.
     * @param executionIndicatorKey - Indicator property name to mark a value
     * to evaluate.
     * @returns Evaluated given mapping.
     */
    static resolveDynamicDataStructure(object, configuration = null, deep = true, evaluationIndicatorKey = '__evaluate__', executionIndicatorKey = '__execute__') {
        if (configuration === null && typeof object === 'object') configuration = object;
        if (deep && configuration && !configuration.__target__) configuration = Helper.addDynamicGetterAndSetter(configuration, value => Helper.resolveDynamicDataStructure(value, configuration, false, evaluationIndicatorKey, executionIndicatorKey), (key, value) => value, '[]', '');
        if (typeof object === 'object' && object !== null) {
            for (const key in object) if ([evaluationIndicatorKey, executionIndicatorKey].includes(key)) try {
                const evaluationFunction = new Function('self', 'webOptimizerPath', 'currentPath', 'path', 'helper', (key === evaluationIndicatorKey ? 'return ' : '') + object[key]);
                return Helper.resolveDynamicDataStructure(evaluationFunction(configuration, __dirname, process.cwd(), _path2.default, Helper), configuration, false, evaluationIndicatorKey, executionIndicatorKey);
            } catch (error) {
                throw Error('Error during ' + (key === evaluationIndicatorKey ? 'executing' : 'evaluating') + ` "${ object[key] }": ` + error);
            } else if (deep) object[key] = Helper.resolveDynamicDataStructure(object[key], configuration, deep, evaluationIndicatorKey, executionIndicatorKey);
        } else if (deep && Array.isArray(object)) {
            let index = 0;
            for (const value of object) {
                object[index] = Helper.resolveDynamicDataStructure(value, configuration, deep, evaluationIndicatorKey, executionIndicatorKey);
                index += 1;
            }
        }
        return object;
    }
    /**
     * Determines a concrete file path for given module id.
     * @param moduleID - Module id to determine.
     * @param aliases - Mapping of aliases to take into account.
     * @returns The alias applied given module id.
     */
    static applyAliases(moduleID, aliases) {
        for (const alias in aliases) if (alias.endsWith('$')) {
            if (moduleID === alias.substring(0, alias.length - 1)) moduleID = aliases[alias];
        } else moduleID = moduleID.replace(alias, aliases[alias]);
        return moduleID;
    }
    /**
     * Determines a concrete file path for given module id.
     * @param moduleID - Module id to determine.
     * @param moduleAliases - Mapping of aliases to take into account.
     * @param knownExtensions - List of known extensions.
     * @param context - File path to determine relative to.
     * @returns File path or given module id if determinations has failed or
     * wasn't necessary.
     */
    static determineModuleFilePath(moduleID, moduleAliases = {}, knownExtensions = ['.js'], context = './') {
        moduleID = Helper.applyAliases(moduleID, moduleAliases);
        for (const moduleLocation of ['', 'node_modules', '../']) for (let fileName of ['__package__', '', 'index', 'main']) for (const extension of knownExtensions) {
            let moduleFilePath = moduleID;
            if (!moduleFilePath.startsWith('/')) moduleFilePath = _path2.default.join(context, moduleLocation, moduleFilePath);
            if (fileName === '__package__') {
                try {
                    if (fileSystem.statSync(moduleFilePath).isDirectory()) {
                        const pathToPackageJSON = _path2.default.join(moduleFilePath, 'package.json');
                        if (fileSystem.statSync(pathToPackageJSON).isFile()) {
                            const localConfiguration = JSON.parse(fileSystem.readFileSync(pathToPackageJSON, {
                                encoding: 'utf-8' }));
                            if (localConfiguration.main) fileName = localConfiguration.main;
                        }
                    }
                } catch (error) {}
                if (fileName === '__package__') continue;
            }
            moduleFilePath = _path2.default.join(moduleFilePath, fileName);
            moduleFilePath += extension;
            try {
                if (fileSystem.statSync(moduleFilePath).isFile()) return moduleFilePath;
            } catch (error) {}
        }
        return moduleID;
    }
}
exports.default = Helper; // endregion
// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion

//# sourceMappingURL=data:application/json;base64,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QUFXLFFBQVgsQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEMsRUFBSixFQUNJLE9BQU8sY0FBUDtBQUNQLGFBSEQsQ0FHRSxPQUFPLEtBQVAsRUFBYyxDQUFFO0FBQ3JCO0FBQ1QsZUFBTyxRQUFQO0FBQ0g7QUFycEJ1QjtrQkFBUCxNLENBdXBCckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJoZWxwZXIuY29tcGlsZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG4vLyBAZmxvd1xuLy8gLSotIGNvZGluZzogdXRmLTggLSotXG4ndXNlIHN0cmljdCdcbi8qICFcbiAgICByZWdpb24gaGVhZGVyXG4gICAgQ29weXJpZ2h0IFRvcmJlbiBTaWNrZXJ0IChpbmZvW1wifmF0flwiXXRvcmJlbi53ZWJzaXRlKSAxNi4xMi4yMDEyXG5cbiAgICBMaWNlbnNlXG4gICAgLS0tLS0tLVxuXG4gICAgVGhpcyBsaWJyYXJ5IHdyaXR0ZW4gYnkgVG9yYmVuIFNpY2tlcnQgc3RhbmQgdW5kZXIgYSBjcmVhdGl2ZSBjb21tb25zIG5hbWluZ1xuICAgIDMuMCB1bnBvcnRlZCBsaWNlbnNlLiBzZWUgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wL2RlZWQuZGVcbiAgICBlbmRyZWdpb25cbiovXG4vLyByZWdpb24gaW1wb3J0c1xuaW1wb3J0IHtDaGlsZFByb2Nlc3N9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgKiBhcyBmaWxlU3lzdGVtIGZyb20gJ2ZzJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbi8vIE5PVEU6IE9ubHkgbmVlZGVkIGZvciBkZWJ1Z2dpbmcgdGhpcyBmaWxlLlxudHJ5IHtcbiAgICByZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXInKVxufSBjYXRjaCAoZXJyb3IpIHt9XG5cbmltcG9ydCB0eXBlIHtcbiAgICBCdWlsZENvbmZpZ3VyYXRpb24sIEV2YWx1YXRpb25GdW5jdGlvbiwgR2V0dGVyRnVuY3Rpb24sIEluamVjdGlvbixcbiAgICBJbnRlcm5hbEluamVjdGlvbiwgTm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uLCBQYXRocywgUGxhaW5PYmplY3QsXG4gICAgUmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb24sIFJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbSwgU2V0dGVyRnVuY3Rpb24sXG4gICAgVHJhdmVyc2VGaWxlc0NhbGxiYWNrRnVuY3Rpb25cbn0gZnJvbSAnLi90eXBlJ1xuLy8gZW5kcmVnaW9uXG4vLyByZWdpb24gZGVjbGFyYXRpb25zXG4vLyBOT1RFOiBUaGlzIGRlY2xhcmF0aW9uIGlzbid0IG5lZWRlZCBpZiBmbG93IGtub3dzIGphdmFTY3JpcHQncyBuYXRpdmVcbi8vIFwiUHJveHlcIiBpbiBmdXR1cmUuXG5kZWNsYXJlIGNsYXNzIFByb3h5IHtcbiAgICBjb25zdHJ1Y3RvcihvYmplY3Q6YW55LCBoYW5kbGVyOk9iamVjdCk6YW55XG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBtZXRob2RzXG4vKipcbiAqIFByb3ZpZGVzIGEgY2xhc3Mgb2Ygc3RhdGljIG1ldGhvZHMgd2l0aCBnZW5lcmljIHVzZSBjYXNlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyIHtcbiAgICAvLyByZWdpb24gYm9vbGVhblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3ZWF0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHBsYWluIG5hdGl2ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBnaXZlbiBvYmplY3QgaXMgYSBwbGFpbiBqYXZhU2NyaXB0IG9iamVjdCBhbmRcbiAgICAgKiBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BsYWluT2JqZWN0KG9iamVjdDptaXhlZCk6Ym9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2VhdGhlciBnaXZlbiBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGdpdmVuIG9iamVjdCBpcyBhIGZ1bmN0aW9uIGFuZCBcImZhbHNlXCJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24ob2JqZWN0Om1peGVkKTpib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KSAmJiB7fS50b1N0cmluZy5jYWxsKFxuICAgICAgICAgICAgb2JqZWN0XG4gICAgICAgICkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGdpdmVuIGZpbGUgcGF0aCBpcyB3aXRoaW4gZ2l2ZW4gbGlzdCBvZiBmaWxlXG4gICAgICogbG9jYXRpb25zLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFBhdGggdG8gZmlsZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gbG9jYXRpb25zVG9DaGVjayAtIExvY2F0aW9ucyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBnaXZlbiBmaWxlIHBhdGggaXMgd2l0aGluIG9uZSBvZiBnaXZlblxuICAgICAqIGxvY2F0aW9ucyBvciBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZpbGVQYXRoSW5Mb2NhdGlvbihcbiAgICAgICAgZmlsZVBhdGg6c3RyaW5nLCBsb2NhdGlvbnNUb0NoZWNrOkFycmF5PHN0cmluZz5cbiAgICApOmJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGhUb0NoZWNrOnN0cmluZyBvZiBsb2NhdGlvbnNUb0NoZWNrKVxuICAgICAgICAgICAgaWYgKHBhdGgucmVzb2x2ZShmaWxlUGF0aCkuc3RhcnRzV2l0aChwYXRoLnJlc29sdmUocGF0aFRvQ2hlY2spKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBnaXZlbiBuYW1lIGludG8gYSB2YWxpZCBqYXZhU2NyaXB0IG9uZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFRvVmFsaWRWYXJpYWJsZU5hbWUobmFtZTpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL15bXmEtekEtWl8kXSsvLCAnJykucmVwbGFjZShcbiAgICAgICAgICAgIC9bXjAtOWEtekEtWl8kXSsoW2EtekEtWjAtOV0pL2csIChcbiAgICAgICAgICAgICAgICBmdWxsTWF0Y2g6c3RyaW5nLCBmaXJzdExldHRlcjpzdHJpbmdcbiAgICAgICAgICAgICk6c3RyaW5nID0+IGZpcnN0TGV0dGVyLnRvVXBwZXJDYXNlKCkpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dGVuZHMgZ2l2ZW4gdGFyZ2V0IG9iamVjdCB3aXRoIGdpdmVuIHNvdXJjZXMgb2JqZWN0LiBBcyB0YXJnZXQgYW5kXG4gICAgICogc291cmNlcyBtYW55IGV4cGFuZGFibGUgdHlwZXMgYXJlIGFsbG93ZWQgYnV0IHRhcmdldCBhbmQgc291cmNlcyBoYXZlIHRvXG4gICAgICogdG8gY29tZSBmcm9tIHRoZSBzYW1lIHR5cGUuXG4gICAgICogQHBhcmFtIHRhcmdldE9yRGVlcEluZGljYXRvciAtIE1heWJlIHRoZSB0YXJnZXQgb3IgZGVlcCBpbmRpY2F0b3IuXG4gICAgICogQHBhcmFtIF90YXJnZXRBbmRPclNvdXJjZXMgLSBUYXJnZXQgYW5kIGF0IGxlYXN0IG9uZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gdGFyZ2V0IGV4dGVuZGVkIHdpdGggYWxsIGdpdmVuIHNvdXJjZXMuXG4gICAgICovXG4gICAgc3RhdGljIGV4dGVuZE9iamVjdChcbiAgICAgICAgdGFyZ2V0T3JEZWVwSW5kaWNhdG9yOmJvb2xlYW58YW55LFxuICAgICAgICAuLi5fdGFyZ2V0QW5kT3JTb3VyY2VzOkFycmF5PGFueT5cbiAgICApOmFueSB7XG4gICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAxXG4gICAgICAgIGxldCBkZWVwOmJvb2xlYW4gPSBmYWxzZVxuICAgICAgICBsZXQgdGFyZ2V0Om1peGVkXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0T3JEZWVwSW5kaWNhdG9yID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb24gYW5kIHNraXAgZGVlcCBpbmRpY2F0b3IgYW5kIHRhcmdldC5cbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXRPckRlZXBJbmRpY2F0b3JcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgaW5kZXggPSAyXG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0T3JEZWVwSW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IG1lcmdlVmFsdWUgPSAoa2V5OnN0cmluZywgdmFsdWU6YW55LCB0YXJnZXRWYWx1ZTphbnkpOmFueSA9PiB7XG4gICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXMuXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiB2YWx1ZSAmJiAoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgSGVscGVyLmlzUGxhaW5PYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvbmVcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gdGFyZ2V0VmFsdWUgJiYgQXJyYXkuaXNBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICkgPyB0YXJnZXRWYWx1ZSA6IFtdXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gdGFyZ2V0VmFsdWUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICAgICAgICAgKSA/IHRhcmdldFZhbHVlIDogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHRhcmdldFZhbHVlICYmIEhlbHBlci5pc1BsYWluT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSA/IHRhcmdldFZhbHVlIDoge31cbiAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW0uXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlci5leHRlbmRPYmplY3QoZGVlcCwgY2xvbmUsIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlOmFueSA9IGFyZ3VtZW50c1tpbmRleF1cbiAgICAgICAgICAgIGxldCB0YXJnZXRUeXBlOnN0cmluZyA9IHR5cGVvZiB0YXJnZXRcbiAgICAgICAgICAgIGxldCBzb3VyY2VUeXBlOnN0cmluZyA9IHR5cGVvZiBzb3VyY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSArPSAnIE1hcCdcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZSArPSAnIE1hcCdcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlICE9PSBzb3VyY2VUeXBlKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgQ2FuJ3QgbWVyZ2UgZ2l2ZW4gdGFyZ2V0IHR5cGUgXCIke3RhcmdldFR5cGV9XCIgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGdpdmVuIHNvdXJjZSB0eXBlIFwiJHtzb3VyY2VUeXBlfVwiICgke2luZGV4fS4gYXJndW1lbnQpLmApXG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCEoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHNvdXJjZSBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5OnN0cmluZywgdmFsdWU6YW55XSBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbWVyZ2VWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlLCB0YXJnZXQuZ2V0KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldChrZXksIG5ld1ZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0ICYmIHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbWVyZ2VWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LCBzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yd2FyZHMgZ2l2ZW4gY2hpbGQgcHJvY2VzcyBjb21tdW5pY2F0aW9uIGNoYW5uZWxzIHRvIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBjdXJyZW50IHByb2Nlc3MgY29tbXVuaWNhdGlvbiBjaGFubmVscy5cbiAgICAgKiBAcGFyYW0gY2hpbGRQcm9jZXNzIC0gQ2hpbGQgcHJvY2VzcyBtZXRhIGRhdGEuXG4gICAgICogQHJldHVybnMgR2l2ZW4gY2hpbGQgcHJvY2VzcyBtZXRhIGRhdGEuXG4gICAgICovXG4gICAgc3RhdGljIGhhbmRsZUNoaWxkUHJvY2VzcyhjaGlsZFByb2Nlc3M6Q2hpbGRQcm9jZXNzKTpDaGlsZFByb2Nlc3Mge1xuICAgICAgICBjaGlsZFByb2Nlc3Muc3Rkb3V0LnBpcGUocHJvY2Vzcy5zdGRvdXQpXG4gICAgICAgIGNoaWxkUHJvY2Vzcy5zdGRlcnIucGlwZShwcm9jZXNzLnN0ZGVycilcbiAgICAgICAgY2hpbGRQcm9jZXNzLm9uKCdjbG9zZScsIChyZXR1cm5Db2RlOm51bWJlcik6dm9pZCA9PiB7XG4gICAgICAgICAgICBpZiAocmV0dXJuQ29kZSAhPT0gMClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUYXNrIGV4aXRlZCB3aXRoIGVycm9yIGNvZGUgJHtyZXR1cm5Db2RlfWApXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjaGlsZFByb2Nlc3NcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBnaXZlbiBkaXJlY3Rvcnkgc3RydWN0dXJlIHJlY3Vyc2l2ZWx5IGFuZCBjYWxscyBnaXZlblxuICAgICAqIGNhbGxiYWNrIGZvciBlYWNoIGZvdW5kIGZpbGUuIENhbGxiYWNrIGdldHMgZmlsZSBwYXRoIGFuZCBjb3JyZXNwb25kaW5nXG4gICAgICogc3RhdCBvYmplY3QgYXMgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIGRpcmVjdG9yeVBhdGggLSBQYXRoIHRvIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2UuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHRyYXZlcnNlZCBmaWxlLlxuICAgICAqIEByZXR1cm5zIEdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyB3YWxrRGlyZWN0b3J5UmVjdXJzaXZlbHlTeW5jKFxuICAgICAgICBkaXJlY3RvcnlQYXRoOnN0cmluZywgY2FsbGJhY2s6VHJhdmVyc2VGaWxlc0NhbGxiYWNrRnVuY3Rpb24gPSAoXG4gICAgICAgICAgICBfZmlsZVBhdGg6c3RyaW5nLCBfc3RhdDpPYmplY3RcbiAgICAgICAgKTo/Ym9vbGVhbiA9PiB0cnVlXG4gICAgKTpUcmF2ZXJzZUZpbGVzQ2FsbGJhY2tGdW5jdGlvbiB7XG4gICAgICAgIGZpbGVTeXN0ZW0ucmVhZGRpclN5bmMoZGlyZWN0b3J5UGF0aCkuZm9yRWFjaCgoXG4gICAgICAgICAgICBmaWxlTmFtZTpzdHJpbmdcbiAgICAgICAgKTp2b2lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoOnN0cmluZyA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnlQYXRoLCBmaWxlTmFtZSlcbiAgICAgICAgICAgIGNvbnN0IHN0YXQ6T2JqZWN0ID0gZmlsZVN5c3RlbS5zdGF0U3luYyhmaWxlUGF0aClcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhmaWxlUGF0aCwgc3RhdCkgIT09IGZhbHNlICYmIHN0YXQgJiYgc3RhdC5pc0RpcmVjdG9yeShcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgSGVscGVyLndhbGtEaXJlY3RvcnlSZWN1cnNpdmVseVN5bmMoZmlsZVBhdGgsIGNhbGxiYWNrKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhIGFzc2V0IHR5cGUgaWYgZ2l2ZW4gZmlsZS5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBQYXRoIHRvIGZpbGUgdG8gYW5hbHlzZS5cbiAgICAgKiBAcGFyYW0gYnVpbGRDb25maWd1cmF0aW9uIC0gTWV0YSBpbmZvcm1hdGlvbnMgZm9yIGF2YWlsYWJsZSBhc3NldFxuICAgICAqIHR5cGVzLlxuICAgICAqIEBwYXJhbSBwYXRocyAtIExpc3Qgb2YgcGF0aHMgdG8gc2VhcmNoIGlmIGdpdmVuIHBhdGggZG9lc24ndCByZWZlcmVuY2VcbiAgICAgKiBhIGZpbGUgZGlyZWN0bHkuXG4gICAgICogQHJldHVybnMgRGV0ZXJtaW5lZCBmaWxlIHR5cGUgb3IgXCJudWxsXCIgb2YgZ2l2ZW4gZmlsZSBjb3VsZG4ndCBiZVxuICAgICAqIGRldGVybWluZWQuXG4gICAgICovXG4gICAgc3RhdGljIGRldGVybWluZUFzc2V0VHlwZShcbiAgICAgICAgZmlsZVBhdGg6c3RyaW5nLCBidWlsZENvbmZpZ3VyYXRpb246QnVpbGRDb25maWd1cmF0aW9uLCBwYXRoczpQYXRoc1xuICAgICk6P3N0cmluZyB7XG4gICAgICAgIGxldCByZXN1bHQ6P3N0cmluZyA9IG51bGxcbiAgICAgICAgZm9yIChjb25zdCB0eXBlOnN0cmluZyBpbiBidWlsZENvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICBpZiAocGF0aC5leHRuYW1lKFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoXG4gICAgICAgICAgICApID09PSBgLiR7YnVpbGRDb25maWd1cmF0aW9uW3R5cGVdLmV4dGVuc2lvbn1gKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHlwZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlOnN0cmluZyBvZiBbJ3NvdXJjZScsICd0YXJnZXQnXSlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFzc2V0VHlwZTpzdHJpbmcgaW4gcGF0aHMuYXNzZXQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRocy5hc3NldFthc3NldFR5cGVdLnN0YXJ0c1dpdGgocGF0aC5qb2luKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHNbdHlwZV0sIHBhdGhzLmFzc2V0W2Fzc2V0VHlwZV1cbiAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRUeXBlXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IHdpdGggYSBzdG9yZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGZpbGUgcGF0aHMsIHdoaWNoXG4gICAgICogbWF0Y2hlcyBlYWNoIGJ1aWxkIGNvbmZpZ3VyYXRpb24gaW4gZ2l2ZW4gZW50cnkgcGF0aCBhbmQgY29udmVydHMgZ2l2ZW5cbiAgICAgKiBidWlsZCBjb25maWd1cmF0aW9uIGludG8gYSBzb3J0ZWQgYXJyYXkgd2VyZSBqYXZhU2NyaXB0IGZpbGVzIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKiBAcGFyYW0gY29uZmlndXJhdGlvbiAtIEdpdmVuIGJ1aWxkIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqIEBwYXJhbSBlbnRyeVBhdGggLSBQYXRoIHRvIGFuYWx5c2UgbmVzdGVkIHN0cnVjdHVyZS5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIFBhdGggdG8gc2V0IHBhdGhzIHJlbGF0aXZlIHRvIGFuZCBkZXRlcm1pbmUgcmVsYXRpdmVcbiAgICAgKiBpZ25vcmVkIHBhdGhzIHRvLlxuICAgICAqIEBwYXJhbSBwYXRoc1RvSWdub3JlIC0gUGF0aHMgd2hpY2ggbWFya3MgbG9jYXRpb24gdG8gaWdub3JlIChSZWxhdGl2ZVxuICAgICAqIHBhdGhzIGFyZSByZXNvbHZlZCByZWxhdGl2ZWx5IHRvIGdpdmVuIGNvbnRleHQuKS5cbiAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgYnVpbGQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUJ1aWxkQ29uZmlndXJhdGlvbkZpbGVQYXRocyhcbiAgICAgICAgY29uZmlndXJhdGlvbjpCdWlsZENvbmZpZ3VyYXRpb24sIGVudHJ5UGF0aDpzdHJpbmcgPSAnLi8nLFxuICAgICAgICBjb250ZXh0OnN0cmluZyA9ICcuLycsIHBhdGhzVG9JZ25vcmU6QXJyYXk8c3RyaW5nPiA9IFsnLmdpdCddXG4gICAgKTpSZXNvbHZlZEJ1aWxkQ29uZmlndXJhdGlvbiB7XG4gICAgICAgIGNvbnN0IGJ1aWxkQ29uZmlndXJhdGlvbjpSZXNvbHZlZEJ1aWxkQ29uZmlndXJhdGlvbiA9IFtdXG4gICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgIGZvciAoY29uc3QgdHlwZTpzdHJpbmcgaW4gY29uZmlndXJhdGlvbilcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbTpSZXNvbHZlZEJ1aWxkQ29uZmlndXJhdGlvbkl0ZW0gPVxuICAgICAgICAgICAgICAgICAgICBIZWxwZXIuZXh0ZW5kT2JqZWN0KHRydWUsIHtmaWxlUGF0aHM6IFtdfSwgY29uZmlndXJhdGlvbltcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVdKVxuICAgICAgICAgICAgICAgIEhlbHBlci53YWxrRGlyZWN0b3J5UmVjdXJzaXZlbHlTeW5jKGVudHJ5UGF0aCwgKChcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6bnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25JdGVtOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbVxuICAgICAgICAgICAgICAgICk6VHJhdmVyc2VGaWxlc0NhbGxiYWNrRnVuY3Rpb24gPT4gKFxuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDpzdHJpbmcsIHN0YXQ6T2JqZWN0XG4gICAgICAgICAgICAgICAgKTo/Ym9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXIuaXNGaWxlUGF0aEluTG9jYXRpb24oZmlsZVBhdGgsIHBhdGhzVG9JZ25vcmUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRmlsZSgpICYmIHBhdGguZXh0bmFtZShmaWxlUGF0aCkuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApID09PSBidWlsZENvbmZpZ3VyYXRpb25JdGVtLmV4dGVuc2lvbiAmJiAhKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25JdGVtLmZpbGVOYW1lUGF0dGVyblxuICAgICAgICAgICAgICAgICAgICApKS50ZXN0KGZpbGVQYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbkl0ZW0uZmlsZVBhdGhzLnB1c2goZmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgfSkoaW5kZXgsIG5ld0l0ZW0pKVxuICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbi5wdXNoKG5ld0l0ZW0pXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRDb25maWd1cmF0aW9uLnNvcnQoKFxuICAgICAgICAgICAgZmlyc3Q6UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb25JdGVtLFxuICAgICAgICAgICAgc2Vjb25kOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbVxuICAgICAgICApOm51bWJlciA9PiB7XG4gICAgICAgICAgICBpZiAoZmlyc3Qub3V0cHV0RXh0ZW5zaW9uICE9PSBzZWNvbmQub3V0cHV0RXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Lm91dHB1dEV4dGVuc2lvbiA9PT0gJ2pzJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgaWYgKHNlY29uZC5vdXRwdXRFeHRlbnNpb24gPT09ICdqcycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Lm91dHB1dEV4dGVuc2lvbiA8IHNlY29uZC5vdXRwdXRFeHRlbnNpb24gPyAtMSA6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYWxsIGZpbGUgYW5kIGRpcmVjdG9yeSBwYXRocyByZWxhdGVkIHRvIGdpdmVuIGludGVybmFsXG4gICAgICogbW9kdWxlcyBhcyBhcnJheS5cbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxJbmplY3Rpb24gLSBMaXN0IG9mIG1vZHVsZUlEcyBvciBtb2R1bGUgZmlsZSBwYXRocy5cbiAgICAgKiBAcGFyYW0gbW9kdWxlQWxpYXNlcyAtIE1hcHBpbmcgb2YgYWxpYXNlcyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ga25vd25FeHRlbnNpb25zIC0gTGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBGaWxlIHBhdGggdG8gcmVzb2x2ZSByZWxhdGl2ZSB0by5cbiAgICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBhIGZpbGUgcGF0aCBhbmQgZGlyZWN0b3J5IHBhdGgga2V5IG1hcHBpbmcgdG9cbiAgICAgKiBjb3JyZXNwb25kaW5nIGxpc3Qgb2YgcGF0aHMuXG4gICAgICovXG4gICAgc3RhdGljIGRldGVybWluZU1vZHVsZUxvY2F0aW9ucyhcbiAgICAgICAgaW50ZXJuYWxJbmplY3Rpb246SW50ZXJuYWxJbmplY3Rpb24sIG1vZHVsZUFsaWFzZXM6UGxhaW5PYmplY3QgPSB7fSxcbiAgICAgICAga25vd25FeHRlbnNpb25zOkFycmF5PHN0cmluZz4gPSBbJy5qcyddLCBjb250ZXh0OnN0cmluZyA9ICcuLydcbiAgICApOntmaWxlUGF0aHM6QXJyYXk8c3RyaW5nPjtkaXJlY3RvcnlQYXRoczpBcnJheTxzdHJpbmc+fSB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoczpBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgY29uc3QgZGlyZWN0b3J5UGF0aHM6QXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbjpOb3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24gPVxuICAgICAgICAgICAgSGVscGVyLm5vcm1hbGl6ZUludGVybmFsSW5qZWN0aW9uKFxuICAgICAgICAgICAgICAgIGludGVybmFsSW5qZWN0aW9uKVxuICAgICAgICBmb3IgKGNvbnN0IGNodW5rTmFtZTpzdHJpbmcgaW4gbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uKVxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShjaHVua05hbWUpKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlSUQ6c3RyaW5nIG9mIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbltcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtOYW1lXG4gICAgICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aDpzdHJpbmcgPSBIZWxwZXIuZGV0ZXJtaW5lTW9kdWxlRmlsZVBhdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVJRCwgbW9kdWxlQWxpYXNlcywga25vd25FeHRlbnNpb25zLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aHMucHVzaChmaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0b3J5UGF0aDpzdHJpbmcgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlyZWN0b3J5UGF0aHMuaW5jbHVkZXMoZGlyZWN0b3J5UGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RvcnlQYXRocy5wdXNoKGRpcmVjdG9yeVBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2ZpbGVQYXRocywgZGlyZWN0b3J5UGF0aHN9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGluamVjdGlvbiBkZWZpbml0aW9uIHR5cGUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIHBsYWluIG9iamVjdFxuICAgICAqIChtYXBwaW5nIGZyb20gY2h1bmsgbmFtZSB0byBhcnJheSBvZiBtb2R1bGUgaWRzKS4gVGhpcyBtZXRob2QgY29udmVydHNcbiAgICAgKiBlYWNoIHJlcHJlc2VudGF0aW9uIGludG8gdGhlIG5vcm1hbGl6ZWQgcGxhaW4gb2JqZWN0IG5vdGF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnRlcm5hbEluamVjdGlvbiAtIEdpdmVuIGludGVybmFsIGluamVjdGlvbiB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMgTm9ybWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBnaXZlbiBpbnRlcm5hbCBpbmplY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZUludGVybmFsSW5qZWN0aW9uKFxuICAgICAgICBpbnRlcm5hbEluamVjdGlvbjpJbnRlcm5hbEluamVjdGlvblxuICAgICk6Tm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uIHtcbiAgICAgICAgbGV0IHJlc3VsdDpOb3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24gPSB7fVxuICAgICAgICBpZiAoaW50ZXJuYWxJbmplY3Rpb24gaW5zdGFuY2VvZiBPYmplY3QgJiYgSGVscGVyLmlzUGxhaW5PYmplY3QoXG4gICAgICAgICAgICBpbnRlcm5hbEluamVjdGlvblxuICAgICAgICApKSB7XG4gICAgICAgICAgICBsZXQgaGFzQ29udGVudDpib29sZWFuID0gZmFsc2VcbiAgICAgICAgICAgIGNvbnN0IGNodW5rTmFtZXNUb0RlbGV0ZTpBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmtOYW1lOnN0cmluZyBpbiBpbnRlcm5hbEluamVjdGlvbilcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxJbmplY3Rpb24uaGFzT3duUHJvcGVydHkoY2h1bmtOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJuYWxJbmplY3Rpb25bY2h1bmtOYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxJbmplY3Rpb25bY2h1bmtOYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY2h1bmtOYW1lXSA9IGludGVybmFsSW5qZWN0aW9uW2NodW5rTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rTmFtZXNUb0RlbGV0ZS5wdXNoKGNodW5rTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NodW5rTmFtZV0gPSBbaW50ZXJuYWxJbmplY3Rpb25bY2h1bmtOYW1lXV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVua05hbWU6c3RyaW5nIG9mIGNodW5rTmFtZXNUb0RlbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtjaHVua05hbWVdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge2luZGV4OiBbXX1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW50ZXJuYWxJbmplY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmVzdWx0ID0ge2luZGV4OiBbaW50ZXJuYWxJbmplY3Rpb25dfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGludGVybmFsSW5qZWN0aW9uKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHtpbmRleDogaW50ZXJuYWxJbmplY3Rpb259XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhbGwgY29uY3JldGUgZmlsZSBwYXRocyBmb3IgZ2l2ZW4gaW5qZWN0aW9uIHdoaWNoIGFyZSBtYXJrZWRcbiAgICAgKiB3aXRoIHRoZSBcIl9fYXV0b19fXCIgaW5kaWNhdG9yLlxuICAgICAqIEBwYXJhbSBnaXZlbkluamVjdGlvbiAtIEdpdmVuIGludGVybmFsIGFuZCBleHRlcm5hbCBpbmplY3Rpb24gdG8gdGFrZVxuICAgICAqIGludG8gYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gYnVpbGRDb25maWd1cmF0aW9ucyAtIFJlc29sdmVkIGJ1aWxkIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIG1vZHVsZXNUb0V4Y2x1ZGUgLSBBIGxpc3Qgb2YgbW9kdWxlcyB0byBleGNsdWRlIChzcGVjaWZpZWQgYnlcbiAgICAgKiBwYXRoIG9yIGlkKSBvciBhIG1hcHBpbmcgZnJvbSBjaHVuayBuYW1lcyB0byBtb2R1bGUgaWRzLlxuICAgICAqIEBwYXJhbSBtb2R1bGVBbGlhc2VzIC0gTWFwcGluZyBvZiBhbGlhc2VzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBrbm93bkV4dGVuc2lvbnMgLSBGaWxlIGV4dGVuc2lvbnMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBGaWxlIHBhdGggdG8gdXNlIGFzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEBwYXJhbSBwYXRoc1RvSWdub3JlIC0gUGF0aHMgd2hpY2ggbWFya3MgbG9jYXRpb24gdG8gaWdub3JlIChSZWxhdGl2ZVxuICAgICAqIHBhdGhzIGFyZSByZXNvbHZlZCByZWxhdGl2ZWx5IHRvIGdpdmVuIGNvbnRleHQuKS5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBpbmplY3Rpb24gd2l0aCByZXNvbHZlZCBtYXJrZWQgaW5kaWNhdG9ycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUluamVjdGlvbihcbiAgICAgICAgZ2l2ZW5JbmplY3Rpb246SW5qZWN0aW9uLFxuICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25zOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uLFxuICAgICAgICBtb2R1bGVzVG9FeGNsdWRlOkludGVybmFsSW5qZWN0aW9uLFxuICAgICAgICBtb2R1bGVBbGlhc2VzOlBsYWluT2JqZWN0ID0ge30sIGtub3duRXh0ZW5zaW9uczpBcnJheTxzdHJpbmc+ID0gW1xuICAgICAgICAgICAgJy5qcycsICcuY3NzJywgJy5zdmcnLCAnLmh0bWwnXG4gICAgICAgIF0sIGNvbnRleHQ6c3RyaW5nID0gJy4vJywgcGF0aHNUb0lnbm9yZTpBcnJheTxzdHJpbmc+ID0gWycuZ2l0J11cbiAgICApOkluamVjdGlvbiB7XG4gICAgICAgIGNvbnN0IGluamVjdGlvbjpJbmplY3Rpb24gPSBIZWxwZXIuZXh0ZW5kT2JqZWN0KFxuICAgICAgICAgICAgdHJ1ZSwge30sIGdpdmVuSW5qZWN0aW9uKVxuICAgICAgICBjb25zdCBtb2R1bGVGaWxlUGF0aHNUb0V4Y2x1ZGU6QXJyYXk8c3RyaW5nPiA9XG4gICAgICAgICAgICBIZWxwZXIuZGV0ZXJtaW5lTW9kdWxlTG9jYXRpb25zKFxuICAgICAgICAgICAgICAgIG1vZHVsZXNUb0V4Y2x1ZGUsIG1vZHVsZUFsaWFzZXMsIGtub3duRXh0ZW5zaW9ucywgY29udGV4dCxcbiAgICAgICAgICAgICAgICBwYXRoc1RvSWdub3JlXG4gICAgICAgICAgICApLmZpbGVQYXRoc1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGU6c3RyaW5nIG9mIFsnaW50ZXJuYWwnLCAnZXh0ZXJuYWwnXSlcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGN1cmx5ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluamVjdGlvblt0eXBlXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rTmFtZTpzdHJpbmcgaW4gaW5qZWN0aW9uW3R5cGVdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5qZWN0aW9uW3R5cGVdW2NodW5rTmFtZV0gPT09ICdfX2F1dG9fXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGlvblt0eXBlXVtjaHVua05hbWVdID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZXM6e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXk6c3RyaW5nXTpzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gPSBIZWxwZXIuZ2V0QXV0b0NodW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbnMsIG1vZHVsZUZpbGVQYXRoc1RvRXhjbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJDaHVua05hbWU6c3RyaW5nIGluIG1vZHVsZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZXMuaGFzT3duUHJvcGVydHkoc3ViQ2h1bmtOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0aW9uW3R5cGVdW2NodW5rTmFtZV0ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZXNbc3ViQ2h1bmtOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmplY3Rpb25bdHlwZV0gPT09ICdfX2F1dG9fXycpXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGN1cmx5ICovXG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uW3R5cGVdID0gSGVscGVyLmdldEF1dG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRDb25maWd1cmF0aW9ucywgbW9kdWxlRmlsZVBhdGhzVG9FeGNsdWRlLCBjb250ZXh0KVxuICAgICAgICByZXR1cm4gaW5qZWN0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYWxsIG1vZHVsZSBmaWxlIHBhdGhzLlxuICAgICAqIEBwYXJhbSBidWlsZENvbmZpZ3VyYXRpb25zIC0gUmVzb2x2ZWQgYnVpbGQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbW9kdWxlRmlsZVBhdGhzVG9FeGNsdWRlIC0gQSBsaXN0IG9mIG1vZHVsZXMgZmlsZSBwYXRocyB0b1xuICAgICAqIGV4Y2x1ZGUgKHNwZWNpZmllZCBieSBwYXRoIG9yIGlkKSBvciBhIG1hcHBpbmcgZnJvbSBjaHVuayBuYW1lcyB0b1xuICAgICAqIG1vZHVsZSBpZHMuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBGaWxlIHBhdGggdG8gdXNlIGFzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEByZXR1cm5zIEFsbCBkZXRlcm1pbmVkIG1vZHVsZSBmaWxlIHBhdGhzLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBdXRvQ2h1bmsoXG4gICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbnM6UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb24sXG4gICAgICAgIG1vZHVsZUZpbGVQYXRoc1RvRXhjbHVkZTpBcnJheTxzdHJpbmc+LCBjb250ZXh0OnN0cmluZ1xuICAgICk6e1trZXk6c3RyaW5nXTpzdHJpbmd9IHtcbiAgICAgICAgY29uc3QgcmVzdWx0Ontba2V5OnN0cmluZ106c3RyaW5nfSA9IHt9XG4gICAgICAgIGNvbnN0IGluamVjdGVkQmFzZU5hbWVzOntba2V5OnN0cmluZ106QXJyYXk8c3RyaW5nPn0gPSB7fVxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29uc3QgYnVpbGRDb25maWd1cmF0aW9uOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbSBvZlxuICAgICAgICAgICAgYnVpbGRDb25maWd1cmF0aW9uc1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICghaW5qZWN0ZWRCYXNlTmFtZXNbYnVpbGRDb25maWd1cmF0aW9uLm91dHB1dEV4dGVuc2lvbl0pXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRCYXNlTmFtZXNbXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbi5vdXRwdXRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICBdID0gW11cbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlRmlsZVBhdGg6c3RyaW5nIG9mIGJ1aWxkQ29uZmlndXJhdGlvbi5maWxlUGF0aHMpXG4gICAgICAgICAgICAgICAgaWYgKCFtb2R1bGVGaWxlUGF0aHNUb0V4Y2x1ZGUuaW5jbHVkZXMobW9kdWxlRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VOYW1lOnN0cmluZyA9IHBhdGguYmFzZW5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVGaWxlUGF0aCwgYC4ke2J1aWxkQ29uZmlndXJhdGlvbi5leHRlbnNpb259YClcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIEVuc3VyZSB0aGF0IGVhY2ggb3V0cHV0IHR5cGUgaGFzIG9ubHkgb25lIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5qZWN0ZWRCYXNlTmFtZXNbXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb24ub3V0cHV0RXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoYmFzZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuc3VyZSB0aGF0IGlmIHNhbWUgYmFzZW5hbWVzIGFuZCBkaWZmZXJlbnQgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgYnkgdGhlaXIgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKEphdmFTY3JpcHQtTW9kdWxlcyByZW1haW5zIHdpdGhvdXQgZXh0ZW5zaW9uIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhleSB3aWxsIGJlIGhhbmRsZWQgZmlyc3QgYmVjYXVzZSB0aGUgYnVpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gYmUgc29ydGVkIGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2Jhc2VOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcGF0aC5yZWxhdGl2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgbW9kdWxlRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXSA9IG1vZHVsZUZpbGVQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2Jhc2VOYW1lXSA9IG1vZHVsZUZpbGVQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RlZEJhc2VOYW1lc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb24ub3V0cHV0RXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBdLnB1c2goYmFzZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGR5bmFtaWMgZ2V0dGVyIGFuZCBzZXR0ZXIgdG8gYW55IGdpdmVuIGRhdGEgc3RydWN0dXJlIHN1Y2ggYXMgbWFwcy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIHByb3h5LlxuICAgICAqIEBwYXJhbSBnZXR0ZXJXcmFwcGVyIC0gRnVuY3Rpb24gdG8gd3JhcCBlYWNoIHByb3BlcnR5IGdldC5cbiAgICAgKiBAcGFyYW0gc2V0dGVyV3JhcHBlciAtIEZ1bmN0aW9uIHRvIHdyYXAgZWFjaCBwcm9wZXJ0eSBzZXQuXG4gICAgICogQHBhcmFtIGdldHRlck1ldGhvZE5hbWUgLSBNZXRob2QgbmFtZSB0byBnZXQgYSBzdG9yZWQgdmFsdWUgYnkga2V5LlxuICAgICAqIEBwYXJhbSBzZXR0ZXJNZXRob2ROYW1lIC0gTWV0aG9kIG5hbWUgdG8gc2V0IGEgc3RvcmVkIHZhbHVlIGJ5IGtleS5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVzTWV0aG9kTmFtZSAtIE1ldGhvZCBuYW1lIHRvIGluZGljYXRlIGlmIGEga2V5IGlzIHN0b3JlZFxuICAgICAqIGluIGdpdmVuIGRhdGEgc3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGVzIHRvIHBlcmZvcm0gYSBkZWVwIHdyYXBwaW5nIG9mIHNwZWNpZmllZCB0eXBlcy5cbiAgICAgKiBwZXJmb3JtZWQgdmlhIFwidmFsdWUgaW5zdGFuY2VvZiB0eXBlXCIuKS5cbiAgICAgKiBAcGFyYW0gdHlwZXNUb0V4dGVuZCAtIFR5cGVzIHdoaWNoIHNob3VsZCBiZSBleHRlbmRlZCAoQ2hlY2tzIGFyZVxuICAgICAqIHBlcmZvcm1lZCB2aWEgXCJ2YWx1ZSBpbnN0YW5jZW9mIHR5cGVcIi4pLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gb2JqZWN0IHdyYXBwZWQgd2l0aCBhIGR5bmFtaWMgZ2V0dGVyIHByb3h5LlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyPFZhbHVlPihcbiAgICAgICAgb2JqZWN0OlZhbHVlLCBnZXR0ZXJXcmFwcGVyOkdldHRlckZ1bmN0aW9uID0gKHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLFxuICAgICAgICBzZXR0ZXJXcmFwcGVyOlNldHRlckZ1bmN0aW9uID0gKGtleTphbnksIHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLFxuICAgICAgICBnZXR0ZXJNZXRob2ROYW1lOnN0cmluZyA9ICdbXScsIHNldHRlck1ldGhvZE5hbWU6c3RyaW5nID0gJ1tdJyxcbiAgICAgICAgY29udGFpbmVzTWV0aG9kTmFtZTpzdHJpbmcgPSAnaGFzT3duUHJvcGVydHknLCBkZWVwOmJvb2xlYW4gPSB0cnVlLFxuICAgICAgICB0eXBlc1RvRXh0ZW5kOkFycmF5PG1peGVkPiA9IFtPYmplY3RdXG4gICAgKTpWYWx1ZSB7XG4gICAgICAgIGlmIChkZWVwKVxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXk6bWl4ZWQsIHZhbHVlOm1peGVkXSBvZiBvYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zZXQoa2V5LCBIZWxwZXIuYWRkRHluYW1pY0dldHRlckFuZFNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBnZXR0ZXJXcmFwcGVyLCBzZXR0ZXJXcmFwcGVyLCBnZXR0ZXJNZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyTWV0aG9kTmFtZSwgY29udGFpbmVzTWV0aG9kTmFtZSwgZGVlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzVG9FeHRlbmQpKVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBIZWxwZXIuYWRkRHluYW1pY0dldHRlckFuZFNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSwgZ2V0dGVyV3JhcHBlciwgc2V0dGVyV3JhcHBlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXJNZXRob2ROYW1lLCBzZXR0ZXJNZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lc01ldGhvZE5hbWUsIGRlZXAsIHR5cGVzVG9FeHRlbmQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTptaXhlZCBvZiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2luZGV4XSA9IEhlbHBlci5hZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGdldHRlcldyYXBwZXIsIHNldHRlcldyYXBwZXIsIGdldHRlck1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJNZXRob2ROYW1lLCBjb250YWluZXNNZXRob2ROYW1lLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNUb0V4dGVuZClcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0eXBlOm1peGVkIG9mIHR5cGVzVG9FeHRlbmQpXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuX190YXJnZXRfXylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXI6e1xuICAgICAgICAgICAgICAgICAgICBoYXM/Oih0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZykgPT4gYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgZ2V0PzoodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpID0+IGFueTtcbiAgICAgICAgICAgICAgICAgICAgc2V0PzoodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpID0+IGFueVxuICAgICAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXNNZXRob2ROYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmhhcyA9ICh0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZyk6Ym9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVzTWV0aG9kTmFtZSA9PT0gJ1tdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbY29udGFpbmVzTWV0aG9kTmFtZV0obmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXNNZXRob2ROYW1lICYmIGdldHRlck1ldGhvZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuZ2V0ID0gKHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nKTphbnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdfX3RhcmdldF9fJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W25hbWVdLmJpbmQodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtjb250YWluZXNNZXRob2ROYW1lXShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXR0ZXJNZXRob2ROYW1lID09PSAnW10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyV3JhcHBlcih0YXJnZXRbbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcldyYXBwZXIodGFyZ2V0W2dldHRlck1ldGhvZE5hbWVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0ZXJNZXRob2ROYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnNldCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nLCB2YWx1ZTphbnlcbiAgICAgICAgICAgICAgICAgICAgKTp2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0ZXJNZXRob2ROYW1lID09PSAnW10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNldHRlcldyYXBwZXIobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3NldHRlck1ldGhvZE5hbWVdKG5hbWUsIHNldHRlcldyYXBwZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkob2JqZWN0LCBoYW5kbGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBuZXN0ZWQgbWFwcGluZ3Mgd2l0aCBnaXZlbiBpbmRpY2F0b3Iga2V5IGFuZCByZXNvbHZlc1xuICAgICAqIG1hcmtlZCB2YWx1ZXMuIEFkZGl0aW9uYWxseSBhbGwgb2JqZWN0cyBhcmUgd3JhcHBlZCB3aXRoIGEgcHJveHkgdG9cbiAgICAgKiBkeW5hbWljYWxseSByZXNvbHZlIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBHaXZlbiBtYXBwaW5nIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gLSBDb25maWd1cmF0aW9uIGNvbnRleHQgdG8gcmVzb2x2ZSBtYXJrZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGVzIHdlYXRoZXIgdG8gcGVyZm9ybSBhIHJlY3Vyc2l2ZSByZXNvbHZpbmcuXG4gICAgICogQHBhcmFtIGV2YWx1YXRpb25JbmRpY2F0b3JLZXkgLSBJbmRpY2F0b3IgcHJvcGVydHkgbmFtZSB0byBtYXJrIGEgdmFsdWVcbiAgICAgKiB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0gZXhlY3V0aW9uSW5kaWNhdG9yS2V5IC0gSW5kaWNhdG9yIHByb3BlcnR5IG5hbWUgdG8gbWFyayBhIHZhbHVlXG4gICAgICogdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMgRXZhbHVhdGVkIGdpdmVuIG1hcHBpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgb2JqZWN0OmFueSwgY29uZmlndXJhdGlvbjo/UGxhaW5PYmplY3QgPSBudWxsLCBkZWVwOmJvb2xlYW4gPSB0cnVlLFxuICAgICAgICBldmFsdWF0aW9uSW5kaWNhdG9yS2V5OnN0cmluZyA9ICdfX2V2YWx1YXRlX18nLFxuICAgICAgICBleGVjdXRpb25JbmRpY2F0b3JLZXk6c3RyaW5nID0gJ19fZXhlY3V0ZV9fJ1xuICAgICk6YW55IHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24gPT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uID0gb2JqZWN0XG4gICAgICAgIGlmIChkZWVwICYmIGNvbmZpZ3VyYXRpb24gJiYgIWNvbmZpZ3VyYXRpb24uX190YXJnZXRfXylcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSBIZWxwZXIuYWRkRHluYW1pY0dldHRlckFuZFNldHRlcihcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLCAoKHZhbHVlOmFueSk6YW55ID0+XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlci5yZXNvbHZlRHluYW1pY0RhdGFTdHJ1Y3R1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgY29uZmlndXJhdGlvbiwgZmFsc2UsIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25JbmRpY2F0b3JLZXkpXG4gICAgICAgICAgICAgICAgKSwgKGtleTphbnksIHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLCAnW10nLCAnJ1xuICAgICAgICAgICAgKVxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgICAgIGlmIChbZXZhbHVhdGlvbkluZGljYXRvcktleSwgZXhlY3V0aW9uSW5kaWNhdG9yS2V5XS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRpb25GdW5jdGlvbjpFdmFsdWF0aW9uRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGYnLCAnd2ViT3B0aW1pemVyUGF0aCcsICdjdXJyZW50UGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXRoJywgJ2hlbHBlcicsICgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IGV2YWx1YXRpb25JbmRpY2F0b3JLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA/ICdyZXR1cm4gJyA6ICcnKSArIG9iamVjdFtrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlci5yZXNvbHZlRHluYW1pY0RhdGFTdHJ1Y3R1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbkZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLCBfX2Rpcm5hbWUsIHByb2Nlc3MuY3dkKCksIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIGNvbmZpZ3VyYXRpb24sIGZhbHNlLCBldmFsdWF0aW9uSW5kaWNhdG9yS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkluZGljYXRvcktleSlcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBkdXJpbmcgJyArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSBldmFsdWF0aW9uSW5kaWNhdG9yS2V5ID8gJ2V4ZWN1dGluZycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXZhbHVhdGluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICsgYCBcIiR7b2JqZWN0W2tleV19XCI6IGAgKyBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlZXApXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gSGVscGVyLnJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBjb25maWd1cmF0aW9uLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbkluZGljYXRvcktleSwgZXhlY3V0aW9uSW5kaWNhdG9yS2V5KVxuICAgICAgICB9IGVsc2UgaWYgKGRlZXAgJiYgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTptaXhlZCBvZiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbaW5kZXhdID0gSGVscGVyLnJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGNvbmZpZ3VyYXRpb24sIGRlZXAsIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkluZGljYXRvcktleSlcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGEgY29uY3JldGUgZmlsZSBwYXRoIGZvciBnaXZlbiBtb2R1bGUgaWQuXG4gICAgICogQHBhcmFtIG1vZHVsZUlEIC0gTW9kdWxlIGlkIHRvIGRldGVybWluZS5cbiAgICAgKiBAcGFyYW0gYWxpYXNlcyAtIE1hcHBpbmcgb2YgYWxpYXNlcyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWxpYXMgYXBwbGllZCBnaXZlbiBtb2R1bGUgaWQuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5QWxpYXNlcyhtb2R1bGVJRDpzdHJpbmcsIGFsaWFzZXM6UGxhaW5PYmplY3QpOnN0cmluZyB7XG4gICAgICAgIGZvciAoY29uc3QgYWxpYXM6c3RyaW5nIGluIGFsaWFzZXMpXG4gICAgICAgICAgICBpZiAoYWxpYXMuZW5kc1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVJRCA9PT0gYWxpYXMuc3Vic3RyaW5nKDAsIGFsaWFzLmxlbmd0aCAtIDEpKVxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IGFsaWFzZXNbYWxpYXNdXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IG1vZHVsZUlELnJlcGxhY2UoYWxpYXMsIGFsaWFzZXNbYWxpYXNdKVxuICAgICAgICByZXR1cm4gbW9kdWxlSURcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhIGNvbmNyZXRlIGZpbGUgcGF0aCBmb3IgZ2l2ZW4gbW9kdWxlIGlkLlxuICAgICAqIEBwYXJhbSBtb2R1bGVJRCAtIE1vZHVsZSBpZCB0byBkZXRlcm1pbmUuXG4gICAgICogQHBhcmFtIG1vZHVsZUFsaWFzZXMgLSBNYXBwaW5nIG9mIGFsaWFzZXMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIGtub3duRXh0ZW5zaW9ucyAtIExpc3Qgb2Yga25vd24gZXh0ZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIEZpbGUgcGF0aCB0byBkZXRlcm1pbmUgcmVsYXRpdmUgdG8uXG4gICAgICogQHJldHVybnMgRmlsZSBwYXRoIG9yIGdpdmVuIG1vZHVsZSBpZCBpZiBkZXRlcm1pbmF0aW9ucyBoYXMgZmFpbGVkIG9yXG4gICAgICogd2Fzbid0IG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZXJtaW5lTW9kdWxlRmlsZVBhdGgoXG4gICAgICAgIG1vZHVsZUlEOnN0cmluZywgbW9kdWxlQWxpYXNlczpQbGFpbk9iamVjdCA9IHt9LFxuICAgICAgICBrbm93bkV4dGVuc2lvbnM6QXJyYXk8c3RyaW5nPiA9IFsnLmpzJ10sIGNvbnRleHQ6c3RyaW5nID0gJy4vJ1xuICAgICk6c3RyaW5nIHtcbiAgICAgICAgbW9kdWxlSUQgPSBIZWxwZXIuYXBwbHlBbGlhc2VzKG1vZHVsZUlELCBtb2R1bGVBbGlhc2VzKVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUxvY2F0aW9uOnN0cmluZyBvZiBbJycsICdub2RlX21vZHVsZXMnLCAnLi4vJ10pXG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlTmFtZTpzdHJpbmcgb2YgWydfX3BhY2thZ2VfXycsICcnLCAnaW5kZXgnLCAnbWFpbiddKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uOnN0cmluZyBvZiBrbm93bkV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZHVsZUZpbGVQYXRoOnN0cmluZyA9IG1vZHVsZUlEXG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9kdWxlRmlsZVBhdGguc3RhcnRzV2l0aCgnLycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlRmlsZVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgbW9kdWxlTG9jYXRpb24sIG1vZHVsZUZpbGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUgPT09ICdfX3BhY2thZ2VfXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVTeXN0ZW0uc3RhdFN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUZpbGVQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhUb1BhY2thZ2VKU09OOnN0cmluZyA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUZpbGVQYXRoLCAncGFja2FnZS5qc29uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVTeXN0ZW0uc3RhdFN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVG9QYWNrYWdlSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbENvbmZpZ3VyYXRpb246UGxhaW5PYmplY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoZmlsZVN5c3RlbS5yZWFkRmlsZVN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhUb1BhY2thZ2VKU09OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogJ3V0Zi04J30pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsQ29uZmlndXJhdGlvbi5tYWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gbG9jYWxDb25maWd1cmF0aW9uLm1haW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lID09PSAnX19wYWNrYWdlX18nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRmlsZVBhdGggPSBwYXRoLmpvaW4obW9kdWxlRmlsZVBhdGgsIGZpbGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVGaWxlUGF0aCArPSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlU3lzdGVtLnN0YXRTeW5jKG1vZHVsZUZpbGVQYXRoKS5pc0ZpbGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlSURcbiAgICB9XG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiB2aW0gbW9kbGluZVxuLy8gdmltOiBzZXQgdGFic3RvcD00IHNoaWZ0d2lkdGg9NCBleHBhbmR0YWI6XG4vLyB2aW06IGZvbGRtZXRob2Q9bWFya2VyIGZvbGRtYXJrZXI9cmVnaW9uLGVuZHJlZ2lvbjpcbi8vIGVuZHJlZ2lvblxuIl19